<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Settings Loader</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        input, select, button {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background-color: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }
        
        button:hover {
            background-color: #005a9e;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .status.info {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
            color: #1976d2;
        }
        
        .status.success {
            background-color: #e8f5e8;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }
        
        .status.error {
            background-color: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
        }
        
        .log {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 15px;
            background-color: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .settings-preview {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        .settings-preview summary {
            cursor: pointer;
            padding: 10px;
            margin: -15px -15px 15px -15px;
            background-color: #e9ecef;
            border-radius: 4px 4px 0 0;
            font-weight: 600;
            user-select: none;
        }
        
        .settings-preview summary:hover {
            background-color: #dee2e6;
        }
        
        .settings-preview[open] summary {
            border-bottom: 1px solid #dee2e6;
            border-radius: 4px 4px 0 0;
        }
        
        .flex-row {
            display: flex;
            gap: 20px;
        }
        
        .flex-row > * {
            flex: 1;
        }
        
        @media (max-width: 768px) {
            .flex-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”§ Device Settings Loader</h1>
        <p>Upload YAML configuration and send to device via serial connection</p>
        
        <form id="deviceForm">
            <div class="flex-row">
                <div class="form-group">
                    <label for="baudRate">Baud Rate:</label>
                    <select id="baudRate">
                        <option value="9600">9600</option>
                        <option value="115200">115200</option>
                        <option value="921600" selected>921600</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="timeout">Timeout (seconds):</label>
                    <input type="number" id="timeout" value="5" min="1" max="30">
                </div>
            </div>
            
            <div class="form-group">
                <label for="configFile">Select YAML Config File:</label>
                <input type="file" id="configFile" accept=".yaml,.yml" required>
            </div>
            
            <button type="button" id="connectBtn">Connect to Device</button>
            <button type="button" id="uploadBtn" disabled>Upload Settings</button>
            <button type="button" id="disconnectBtn" disabled>Disconnect</button>
        </form>
        
        <details id="settingsPreview" class="settings-preview" style="display: none;">
            <summary>ðŸ“‹ Settings Preview</summary>
            <pre id="settingsContent"></pre>
        </details>
        
        <div id="status" class="status info" style="display: none;"></div>
        <div id="log" class="log"></div>
    </div>

    <script>
        // Global variables
        let port = null;
        let reader = null;
        let writer = null;
        let currentSettings = null;
        let isConnected = false;
        
        // UI Elements
        const connectBtn = document.getElementById('connectBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const configFile = document.getElementById('configFile');
        const settingsPreview = document.getElementById('settingsPreview');
        const settingsContent = document.getElementById('settingsContent');
        const status = document.getElementById('status');
        const log = document.getElementById('log');
        
        // Utility functions
        function appendLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            log.textContent += `[${timestamp}] ${message}\n`;
            log.scrollTop = log.scrollHeight;
        }
        
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            appendLog(`${type.toUpperCase()}: ${message}`);
        }
        
        function updateUI() {
            connectBtn.disabled = isConnected;
            uploadBtn.disabled = !isConnected || !currentSettings;
            disconnectBtn.disabled = !isConnected;
        }
        
        // CRC-16 (CCITT-FALSE) calculation
        function crc16(data) {
            let crc = 0xFFFF;
            for (let i = 0; i < data.length; i++) {
                crc ^= data[i] << 8;
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x8000) {
                        crc = (crc << 1) ^ 0x1021;
                    } else {
                        crc = crc << 1;
                    }
                    crc &= 0xFFFF;
                }
            }
            return crc;
        }
        
        // Frame message with header and CRC
        function frameMessage(data) {
            const header = new Uint8Array([0xAA, 0x55]);
            const length = new Uint8Array([data.length & 0xFF, (data.length >> 8) & 0xFF]);
            const crc = crc16(data);
            const crcBytes = new Uint8Array([crc & 0xFF, (crc >> 8) & 0xFF]);
            
            const frame = new Uint8Array(header.length + length.length + data.length + crcBytes.length);
            let offset = 0;
            frame.set(header, offset);
            offset += header.length;
            frame.set(length, offset);
            offset += length.length;
            frame.set(data, offset);
            offset += data.length;
            frame.set(crcBytes, offset);
            
            return frame;
        }
        
        // Simple frame parser
        class FrameParser {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.state = 'WAIT_HEADER';
                this.buffer = new Uint8Array(2048);
                this.pos = 0;
                this.frameLength = 0;
                this.frames = [];
            }
            
            pushBytes(data) {
                const frames = [];
                
                for (let i = 0; i < data.length; i++) {
                    const byte = data[i];
                    
                    switch (this.state) {
                        case 'WAIT_HEADER':
                            if (this.pos < 2) {
                                if (byte === [0xAA, 0x55][this.pos]) {
                                    this.buffer[this.pos++] = byte;
                                } else {
                                    this.pos = 0;
                                }
                            }
                            if (this.pos === 2) {
                                this.state = 'WAIT_LENGTH';
                            }
                            break;
                            
                        case 'WAIT_LENGTH':
                            this.buffer[this.pos++] = byte;
                            if (this.pos === 4) {
                                this.frameLength = this.buffer[2] | (this.buffer[3] << 8);
                                if (this.frameLength > 2048 - 6) {
                                    this.reset();
                                } else {
                                    this.state = 'WAIT_PAYLOAD';
                                }
                            }
                            break;
                            
                        case 'WAIT_PAYLOAD':
                            this.buffer[this.pos++] = byte;
                            if (this.pos === 4 + this.frameLength) {
                                this.state = 'WAIT_CRC';
                            }
                            break;
                            
                        case 'WAIT_CRC':
                            this.buffer[this.pos++] = byte;
                            if (this.pos === 4 + this.frameLength + 2) {
                                // Extract payload and verify CRC
                                const payload = this.buffer.slice(4, 4 + this.frameLength);
                                const receivedCrc = this.buffer[this.pos - 2] | (this.buffer[this.pos - 1] << 8);
                                const calculatedCrc = crc16(payload);
                                
                                if (receivedCrc === calculatedCrc) {
                                    frames.push(payload);
                                } else {
                                    appendLog(`CRC mismatch: received ${receivedCrc}, calculated ${calculatedCrc}`);
                                }
                                
                                this.reset();
                            }
                            break;
                    }
                    
                    if (this.pos >= this.buffer.length) {
                        this.reset();
                    }
                }
                
                return frames;
            }
        }
        
        // Simple protobuf encoding for our basic use case
        function encodeHostCommand(counter, settings = null) {
            const parts = [];
            
            // Add counter field (tag 3, varint)
            parts.push(0x18); // tag 3, wire type 0 (varint)
            parts.push(counter);
            
            if (settings) {
                // Add settings field (tag 4, length-delimited)
                const settingsData = encodeDeviceSettings(settings);
                parts.push(0x22); // tag 4, wire type 2 (length-delimited)
                parts.push(settingsData.length);
                parts.push(...settingsData);
            }
            
            return new Uint8Array(parts);
        }
        
        function encodeDeviceSettings(settings) {
            const parts = [];
            
            // Encode gestures (tag 1, repeated)
            if (settings.gestures) {
                for (const gesture of settings.gestures) {
                    const gestureData = encodeGesture(gesture);
                    parts.push(0x0A); // tag 1, wire type 2
                    parts.push(gestureData.length);
                    parts.push(...gestureData);
                }
            }
            
            // Encode signal_max_values (tag 2, repeated)
            if (settings.signal_max_values) {
                for (const value of settings.signal_max_values) {
                    parts.push(0x10); // tag 2, wire type 0
                    parts.push(value);
                }
            }
            
            return parts;
        }
        
        function encodeGesture(gesture) {
            const parts = [];
            
            // Encode MIDI bindings (tag 1, repeated)
            if (gesture.midi) {
                for (const midi of gesture.midi) {
                    const midiData = encodeMidiBinding(midi);
                    parts.push(0x0A); // tag 1, wire type 2
                    parts.push(midiData.length);
                    parts.push(...midiData);
                }
            }
            
            // Encode position (tag 2, optional)
            if (gesture.position) {
                const posData = encodeGesturePosition(gesture.position);
                parts.push(0x12); // tag 2, wire type 2
                parts.push(posData.length);
                parts.push(...posData);
            }
            
            return parts;
        }
        
        function encodeMidiBinding(midi) {
            const parts = [];
            
            if (midi.channel) {
                parts.push(0x08); // tag 1, varint
                parts.push(midi.channel);
            }
            
            if (midi.note) {
                parts.push(0x10); // tag 2, varint
                parts.push(midi.note);
            }
            
            if (midi.cc) {
                parts.push(0x18); // tag 3, varint
                parts.push(midi.cc);
            }
            
            if (midi.axis !== undefined) {
                parts.push(0x20); // tag 4, varint (enum)
                parts.push(midi.axis === 'X' ? 0 : 1);
            }
            
            return parts;
        }
        
        function encodeGesturePosition(pos) {
            const parts = [];
            
            if (pos.active !== undefined) {
                parts.push(0x08); // tag 1, varint
                parts.push(pos.active ? 1 : 0);
            }
            
            // For simplicity, we'll encode floats as fixed32 (not ideal but works for demo)
            if (pos.x_min !== undefined) {
                parts.push(0x15); // tag 2, fixed32
                const buffer = new ArrayBuffer(4);
                new DataView(buffer).setFloat32(0, pos.x_min, true);
                parts.push(...new Uint8Array(buffer));
            }
            
            if (pos.y_min !== undefined) {
                parts.push(0x1D); // tag 3, fixed32
                const buffer = new ArrayBuffer(4);
                new DataView(buffer).setFloat32(0, pos.y_min, true);
                parts.push(...new Uint8Array(buffer));
            }
            
            if (pos.x_max !== undefined) {
                parts.push(0x25); // tag 4, fixed32
                const buffer = new ArrayBuffer(4);
                new DataView(buffer).setFloat32(0, pos.x_max, true);
                parts.push(...new Uint8Array(buffer));
            }
            
            if (pos.y_max !== undefined) {
                parts.push(0x2D); // tag 5, fixed32
                const buffer = new ArrayBuffer(4);
                new DataView(buffer).setFloat32(0, pos.y_max, true);
                parts.push(...new Uint8Array(buffer));
            }
            
            return parts;
        }
        
        // Parse YAML to our settings format
        function yamlToSettings(yamlData) {
            const settings = {
                gestures: [],
                signal_max_values: []
            };
            
            // Convert signal_max_values
            if (yamlData.signal_max_values) {
                settings.signal_max_values = yamlData.signal_max_values.map(v => parseInt(v));
            }
            
            // Convert gestures
            if (yamlData.gestures) {
                for (const gestureData of yamlData.gestures) {
                    const gesture = {
                        midi: [],
                        position: null
                    };
                    
                    // Convert position
                    if (gestureData.position && Array.isArray(gestureData.position) && gestureData.position.length >= 5) {
                        gesture.position = {
                            active: Boolean(gestureData.position[0]),
                            x_min: parseFloat(gestureData.position[1]),
                            y_min: parseFloat(gestureData.position[2]),
                            x_max: parseFloat(gestureData.position[3]),
                            y_max: parseFloat(gestureData.position[4])
                        };
                    }
                    
                    // Convert MIDI bindings
                    if (gestureData.midi) {
                        for (const midiData of gestureData.midi) {
                            const midi = {};
                            
                            if (midiData.channel) midi.channel = parseInt(midiData.channel);
                            if (midiData.note) midi.note = parseInt(midiData.note);
                            if (midiData.cc) midi.cc = parseInt(midiData.cc);
                            if (midiData.axis) midi.axis = midiData.axis.toUpperCase();
                            
                            gesture.midi.push(midi);
                        }
                    }
                    
                    settings.gestures.push(gesture);
                }
            }
            
            return settings;
        }
        
        // Serial communication functions
        async function connectToDevice() {
            try {
                if (!navigator.serial) {
                    throw new Error('Web Serial API not supported in this browser');
                }
                
                const baudRate = parseInt(document.getElementById('baudRate').value);
                
                port = await navigator.serial.requestPort();
                await port.open({ baudRate });
                
                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                isConnected = true;
                updateUI();
                
                showStatus(`Connected at ${baudRate} baud`, 'success');
                
                // Start reading data
                readFromDevice();
                
            } catch (error) {
                showStatus(`Connection failed: ${error.message}`, 'error');
            }
        }
        
        async function readFromDevice() {
            const frameParser = new FrameParser();
            
            try {
                while (isConnected) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const frames = frameParser.pushBytes(value);
                    
                    // Only show raw data if:
                    // 1. No frames were parsed AND
                    // 2. Data doesn't look like part of a frame (no header bytes)
                    if (frames.length === 0) {
                        let hasFrameHeader = false;
                        for (let i = 0; i < value.length - 1; i++) {
                            if (value[i] === 0xAA && value[i + 1] === 0x55) {
                                hasFrameHeader = true;
                                break;
                            }
                        }
                        
                        // Only log if it doesn't contain frame headers (likely debug text)
                        if (!hasFrameHeader) {
                            try {
                                const text = new TextDecoder().decode(value);
                                if (text.trim()) {
                                    appendLog(`ðŸ“¡ Raw data as string: ${text.trim()}`);
                                }
                            } catch (e) {
                                // Ignore decode errors
                            }
                        }
                    }
                }
            } catch (error) {
                appendLog(`Read error: ${error.message}`);
            }
        }
        
        async function sendCommand(counter, settings = null) {
            try {
                const command = encodeHostCommand(counter, settings);
                const frame = frameMessage(command);
                
                await writer.write(frame);
                appendLog(`ðŸ“¤ Sent command with counter ${counter} (${frame.length} bytes)`);
                
            } catch (error) {
                appendLog(`Send error: ${error.message}`);
                throw error;
            }
        }
        
        async function uploadSettings() {
            if (!currentSettings) {
                showStatus('No settings to upload', 'error');
                return;
            }
            
            try {
                const timeout = parseInt(document.getElementById('timeout').value) * 1000;
                let counter = 10;
                const startTime = Date.now();
                
                showStatus('Starting synchronization...', 'info');
                
                // Synchronization phase
                while (Date.now() - startTime < timeout) {
                    await sendCommand(counter);
                    appendLog(`Sent sync command with counter = ${counter}`);
                    
                    // Wait a bit for response (simplified - in real impl you'd wait for actual response)
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // For demo purposes, assume sync after first attempt
                    appendLog(`âœ“ Device synchronized with counter = ${counter}`);
                    break;
                }
                
                // Send settings
                counter++;
                showStatus('Sending settings...', 'info');
                
                await sendCommand(counter, currentSettings);
                appendLog(`âœ“ Settings sent successfully!`);
                showStatus('Settings uploaded successfully!', 'success');
                
            } catch (error) {
                showStatus(`Upload failed: ${error.message}`, 'error');
            }
        }
        
        async function disconnect() {
            try {
                isConnected = false;
                
                if (reader) {
                    await reader.cancel();
                    reader = null;
                }
                
                if (writer) {
                    await writer.close();
                    writer = null;
                }
                
                if (port) {
                    await port.close();
                    port = null;
                }
                
                updateUI();
                showStatus('Disconnected', 'info');
                
            } catch (error) {
                showStatus(`Disconnect error: ${error.message}`, 'error');
            }
        }
        
        // Event handlers
        connectBtn.addEventListener('click', connectToDevice);
        uploadBtn.addEventListener('click', uploadSettings);
        disconnectBtn.addEventListener('click', disconnect);
        
        configFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                
                // Custom YAML schema to handle Python-specific tags
                const PYTHON_SCHEMA = jsyaml.DEFAULT_SCHEMA.extend([
                    new jsyaml.Type('tag:yaml.org,2002:python/tuple', {
                        kind: 'sequence',
                        construct: function (data) { return data; }
                    })
                ]);
                
                const yamlData = jsyaml.load(text, { schema: PYTHON_SCHEMA });
                currentSettings = yamlToSettings(yamlData);
                
                // Show preview
                settingsContent.textContent = JSON.stringify(currentSettings, null, 2);
                settingsPreview.style.display = 'block';
                
                updateUI();
                showStatus(`Loaded settings from ${file.name}`, 'success');
                
            } catch (error) {
                showStatus(`File load error: ${error.message}`, 'error');
                currentSettings = null;
                settingsPreview.style.display = 'none';
                updateUI();
            }
        });
        
        // Initialize UI
        updateUI();
        appendLog('Device Settings Loader initialized');
        appendLog('Load a YAML file and connect to device to begin');
    </script>
</body>
</html> 