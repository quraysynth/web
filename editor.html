<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quray Configuration Editor</title>
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon.png">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <script src="lib/js-yaml.min.js"></script>
    <script src="lib/jszip.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000000;
            color: #ffffff;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 100%;
            height: 100vh;
            margin: 0;
            background: #000000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 20px;
            font-size: 24px;
            padding: 20px 20px 0 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .serial-btn {
            font-size: 13px;
            padding: 6px 14px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            margin-left: auto;
        }

        .serial-btn:hover {
            background: #444;
            border-color: #777;
            color: #fff;
        }

        .serial-btn.connected {
            background: #1a3a1a;
            border-color: #28a745;
            color: #5cff5c;
        }

        .serial-btn.connected:hover {
            background: #2a4a2a;
        }

        .record-btn {
            font-size: 13px;
            padding: 6px 14px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            margin-left: 8px;
        }

        .record-btn:hover {
            background: #444;
            border-color: #777;
            color: #fff;
        }

        .record-btn.recording {
            background: #3a1a1a;
            border-color: #dc3545;
            color: #ff5c5c;
            animation: rec-pulse 1s ease-in-out infinite;
        }

        .calib-btn {
            font-size: 13px;
            padding: 6px 14px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #ccc;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            margin-left: 8px;
        }
        .calib-btn:hover {
            background: #444;
            border-color: #777;
            color: #fff;
        }
        .calib-btn.calibrating {
            background: #1a2a3a;
            border-color: #17a2b8;
            color: #5cdcff;
            animation: rec-pulse 1s ease-in-out infinite;
        }
        .calib-btn.calibrated {
            background: #1a3a2a;
            border-color: #28a745;
            color: #5cff8c;
        }

        @keyframes rec-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 0 20px 20px 20px;
            gap: 20px;
        }

        .left-panel {
            width: 20%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        .center-panel {
            width: 60%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .right-panel {
            width: 20%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #7742ff;
            padding-bottom: 8px;
        }

        .section {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333333;
        }

        .calib-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            margin-bottom: 5px;
            color: #e0e0e0;
            font-size: 14px;
            font-weight: 500;
        }

        .input-group input[type="text"],
        .input-group input[type="number"],
        .input-group select {
            padding: 8px 12px;
            border: 1px solid #333333;
            border-radius: 4px;
            font-size: 14px;
            background: #0a0a0a;
            color: #ffffff;
            transition: border-color 0.2s;
        }

        .input-group input[type="range"] {
            height: 6px;
            background: #333333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .input-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #7742ff;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        .input-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #5d2fd4;
        }

        .input-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #7742ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
        }

        .input-group input[type="range"]::-moz-range-thumb:hover {
            background: #5d2fd4;
        }

        .input-group input[type="text"]:focus,
        .input-group input[type="number"]:focus,
        .input-group select:focus {
            outline: none;
            border-color: #7742ff;
        }

        .config-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 10px;
        }

        .color-picker-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .color-picker-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #333333;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-picker-group input[type="text"] {
            width: 100%;
        }

        .gradient-preview {
            height: 50px;
            border-radius: 4px;
            margin-top: 10px;
            border: 1px solid #333333;
        }

        .control-panel {
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333333;
        }

        .control-panel:first-child {
            flex: 1;
        }

        .gesture-navigation {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .gesture-counter {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
            min-width: 60px;
            text-align: center;
        }

        .nav-button {
            padding: 8px 16px;
            background: #7742ff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-button:hover {
            background: #5d2fd4;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Button colors by function */
        .btn-create {
            background: #28a745;
            border-color: #28a745;
        }

        .btn-create:hover:not(:disabled) {
            background: #218838;
        }

        .btn-delete {
            background: #dc3545;
            border-color: #dc3545;
        }

        .btn-delete:hover:not(:disabled) {
            background: #c82333;
        }

        .btn-edit {
            background: #007bff;
            border-color: #007bff;
        }

        .btn-edit:hover:not(:disabled) {
            background: #0069d9;
        }

        .btn-copy {
            background: #17a2b8;
            border-color: #17a2b8;
        }

        .btn-copy:hover:not(:disabled) {
            background: #138496;
        }

        .btn-clear {
            background: #ffc107;
            color: #000000;
            border-color: #ffc107;
        }

        .btn-clear:hover:not(:disabled) {
            background: #e0a800;
        }

        .btn-play {
            background: #28a745;
            border-color: #28a745;
            font-weight: bold;
        }

        .btn-play:hover:not(:disabled) {
            background: #218838;
        }

        .btn-neutral {
            background: #6c757d;
            border-color: #6c757d;
        }

        .btn-neutral:hover:not(:disabled) {
            background: #5a6268;
        }

        .btn-navigation {
            background: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
        }

        .btn-navigation:hover:not(:disabled) {
            background: #dee2e6;
        }

        .gesture-canvas-container {
            flex: 1;
            border: 2px solid #333333;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0a0a0a;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 10px 16px;
            background: #7742ff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #5d2fd4;
        }

        button.secondary {
            background: #666;
        }

        button.secondary:hover {
            background: #555;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            display: none;
            font-size: 12px;
            margin-top: 10px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .midi-event {
            padding: 10px;
            margin-bottom: 10px;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #333333;
        }

        .midi-event-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: flex-start;
        }

        .midi-event-controls > div {
            flex: 1 1 auto;
            min-width: 60px;
        }

        .midi-event-controls > div:nth-child(1),
        .midi-event-controls > div:nth-child(2) {
            flex: 0 1 70px;
        }

        .midi-event-controls > button {
            flex: 0 0 auto;
            align-self: flex-end;
        }

        .midi-event select,
        .midi-event input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #333333;
            border-radius: 4px;
            font-size: 13px;
            background: #0a0a0a;
            color: #ffffff;
            box-sizing: border-box;
        }

        .midi-event input[type="range"] {
            padding: 0;
            height: 6px;
            background: #333333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .midi-event input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #7742ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .midi-event input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #7742ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .midi-event label {
            font-size: 12px;
            color: #e0e0e0;
            margin-bottom: 3px;
            display: block;
        }

        #playModeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            z-index: 2000;
        }

        #playModeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #playModeInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .audio-indicator {
            display: inline-block;
            margin-left: 5px;
            color: #28a745;
            font-size: 18px;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #playModeGestures {
            font-size: 14px;
            line-height: 1.6;
        }

        .play-mode-gesture-item {
            margin-bottom: 15px;
            padding: 12px;
            background: #1a1a1a;
            border-radius: 4px;
            border-left: 4px solid #7742ff;
        }

        .play-mode-gesture-title {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .play-mode-midi-event {
            margin-left: 10px;
            color: #e0e0e0;
            font-size: 13px;
        }

        .play-mode-exit {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 20px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s;
        }

        .play-mode-exit:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Quray Configuration Editor <button class="calib-btn" id="calibBtn" onclick="startCalibration()" style="display:none">üéØ Calibrate</button><button class="record-btn" id="recordBtn" onclick="toggleRecording()" style="display:none">‚è∫ Record</button><button class="serial-btn" id="serialBtn" onclick="toggleSerial()">‚ö° Connect Serial</button></h1>

        <div class="main-layout">
            <!-- Left Panel (20%) -->
            <div class="left-panel">
                <!-- Calibration Section -->
                <div class="section">
                    <h2>Calibration</h2>
                    <div class="calib-grid" id="calibGrid">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <!-- Config Section -->
                <div class="section">
                    <h2>Configuration</h2>
                    <div class="input-group">
                        <label for="defaultPreset">Default Preset</label>
                        <select id="defaultPreset">
                            <option value="">Select preset...</option>
                        </select>
                    </div>

                    <div style="margin-top: 15px;">
                        <div class="gradient-preview" id="gradientPreview"></div>
                        
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <input type="color" id="color1Picker" style="flex: 1; height: 40px; border: 1px solid #333333; border-radius: 4px; cursor: pointer;">
                            <input type="color" id="color2Picker" style="flex: 1; height: 40px; border: 1px solid #333333; border-radius: 4px; cursor: pointer;">
                        </div>
                        
                        <div style="margin-top: 5px;">
                            <input type="text" id="color1" placeholder="#FE3A86" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; margin-bottom: 5px; background: #0a0a0a; color: #ffffff;">
                            <input type="text" id="color2" placeholder="#7742ff" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                    </div>

                    <div style="margin-top: 20px;">
                        <h3 style="font-size: 14px; color: #e0e0e0; margin-bottom: 10px; border-bottom: 1px solid #333333; padding-bottom: 5px;">WiFi Client</h3>
                        <div class="input-group">
                            <label for="wifiSsid">WiFi SSID</label>
                            <input type="text" id="wifiSsid" placeholder="Network name" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <label for="wifiPassword">WiFi Password</label>
                            <input type="password" id="wifiPassword" placeholder="Password" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                    </div>

                    <div style="margin-top: 20px;">
                        <h3 style="font-size: 14px; color: #e0e0e0; margin-bottom: 10px; border-bottom: 1px solid #333333; padding-bottom: 5px;">WiFi Access Point</h3>
                        <div class="input-group">
                            <label for="wifiApSsid">AP SSID</label>
                            <input type="text" id="wifiApSsid" placeholder="AP name" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <label for="wifiApPassword">AP Password</label>
                            <input type="password" id="wifiApPassword" placeholder="AP password" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                    </div>

                    <div style="margin-top: 20px;">
                        <h3 style="font-size: 14px; color: #e0e0e0; margin-bottom: 10px; border-bottom: 1px solid #333333; padding-bottom: 5px;">Distance Averaging Speed</h3>
                        <div class="input-group">
                            <label for="distanceMinAvgSpeed">Min Avg Speed (0-10)</label>
                            <input type="number" id="distanceMinAvgSpeed" min="0" max="10" placeholder="2" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <label for="distanceMaxAvgSpeed">Max Avg Speed (0-10)</label>
                            <input type="number" id="distanceMaxAvgSpeed" min="0" max="10" placeholder="8" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <label for="distanceAvgResetThreshold">Reset Threshold (mm)</label>
                            <input type="number" id="distanceAvgResetThreshold" min="0" placeholder="100" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <label for="xAvgSpeed">X Avg Speed (0-100)</label>
                            <input type="number" id="xAvgSpeed" min="0" max="100" placeholder="50" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <label for="validStreakThreshold">Valid Streak Threshold</label>
                            <input type="number" id="validStreakThreshold" min="0" placeholder="5" style="width: 100%; padding: 8px 12px; border: 1px solid #333333; border-radius: 4px; font-size: 14px; background: #0a0a0a; color: #ffffff;">
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="section">
                    <div class="button-group">
                        <button onclick="saveAll()">Save All</button>
                        <button class="secondary" onclick="downloadAll()">üì¶ Download ZIP</button>
                        <button class="secondary" onclick="location.reload()">Reload</button>
                    </div>
                    <div class="status" id="status"></div>
                </div>
            </div>

            <!-- Center Panel (60%) -->
            <div class="center-panel">
                <!-- Control Panels -->
                <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                    <!-- Preset Management -->
                    <div class="control-panel">
                        <div class="input-group">
                            <label for="selectedPreset">Preset</label>
                            <div style="display: flex; gap: 5px;">
                                <select id="selectedPreset" style="flex: 1;">
                                    <option value="">Select preset...</option>
                                </select>
                                <button class="nav-button btn-play" onclick="enterPlayMode()" title="Play mode (fullscreen)">‚ñ∂</button>
                                <button class="nav-button btn-edit" onclick="renamePreset()" title="Rename preset">‚úé</button>
                                <button class="nav-button btn-copy" onclick="copyPreset()" title="Copy preset">‚éò</button>
                                <button class="nav-button btn-delete" onclick="deletePreset()" title="Delete preset">‚úï</button>
                                <button class="nav-button btn-clear" onclick="clearPreset()" title="Clear preset">üóë</button>
                                <button class="nav-button btn-create" onclick="createNewPreset()" title="Create new preset">+</button>
                                <button class="nav-button btn-neutral" id="undoButton" onclick="undo()" title="Undo (Ctrl+Z)" disabled>‚Ü∂</button>
                                <button class="nav-button btn-neutral" id="redoButton" onclick="redo()" title="Redo (Ctrl+Y)" disabled>‚Ü∑</button>
                            </div>
                        </div>
                    </div>

                    <!-- Gesture Navigation -->
                    <div class="control-panel">
                        <div class="input-group">
                            <label>Gesture</label>
                            <div class="gesture-navigation" id="gestureNavContainer">
                                <button class="nav-button btn-navigation" onclick="previousGesture()">‚Üê</button>
                                <div class="gesture-counter" id="gestureCounter">-/-</div>
                                <button class="nav-button btn-navigation" onclick="nextGesture()">‚Üí</button>
                                <button class="nav-button btn-create" onclick="startCreateGesture()" title="Create new gesture">+</button>
                                <button class="nav-button btn-delete" onclick="deleteGesture()" title="Delete current gesture">‚úï</button>
                            </div>
                            <div class="gesture-navigation" id="gestureCreateContainer" style="display: none;">
                                <div style="color: #e0e0e0; font-size: 13px;">Draw rectangle on canvas</div>
                                <button class="nav-button btn-delete" onclick="cancelCreateGesture()" title="Cancel">‚úï</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Gesture Canvas -->
                <div class="gesture-canvas-container">
                    <canvas id="gestureCanvas" width="1200" height="600"></canvas>
                </div>
            </div>

            <!-- Right Panel (20%) - MIDI Events and CV Events -->
            <div class="right-panel">
                <div class="section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h2 style="margin: 0;">MIDI Events</h2>
                        <button class="nav-button btn-create" onclick="addMidiEvent()" title="Add MIDI event">+</button>
                    </div>
                    <div id="midiEventsList"></div>
                </div>
                <div class="section" style="margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h2 style="margin: 0;">CV Events</h2>
                        <button class="nav-button btn-create" onclick="addCvEvent()" title="Add CV event">+</button>
                    </div>
                    <div id="cvEventsList"></div>
                </div>
                <div class="section" style="margin-top: 20px;">
                    <h2 style="margin: 0 0 15px 0;">MIDI Control</h2>
                    <div class="calib-grid">
                        <div class="input-group">
                            <label>Control Change (CC)</label>
                            <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                                <input type="number" id="midiCcChannel" min="0" max="15" value="0" placeholder="Ch" style="width: 60px;">
                                <input type="number" id="midiCcNumber" min="0" max="127" value="1" placeholder="CC" style="width: 60px;">
                                <span style="color: #999; font-size: 12px;">Value:</span>
                                <input type="range" id="midiCcValue" min="0" max="127" value="64" style="flex: 1;">
                                <span id="midiCcValueDisplay" style="min-width: 35px; text-align: right; color: #fff;">64</span>
                            </div>
                            <button class="nav-button" onclick="sendMidiCC()" style="width: 100%;">Send CC</button>
                        </div>
                        <div class="input-group" style="margin-top: 15px;">
                            <label>Note On/Off</label>
                            <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                                <input type="number" id="midiNoteChannel" min="0" max="15" value="0" placeholder="Ch" style="width: 60px;">
                                <input type="number" id="midiNoteNumber" min="0" max="127" value="60" placeholder="Note" style="width: 60px;">
                                <input type="number" id="midiNoteVelocity" min="0" max="127" value="100" placeholder="Vel" style="width: 60px;">
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="nav-button" onclick="sendMidiNote(true)" style="flex: 1; background: #28a745;">Note On</button>
                                <button class="nav-button" onclick="sendMidiNote(false)" style="flex: 1; background: #dc3545;">Note Off</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Play Mode Overlay -->
        <div id="playModeOverlay" style="display: none;">
            <canvas id="playModeCanvas"></canvas>
            <div id="playModeInfo">
                <div id="playModeGestures"></div>
            </div>
            <button class="play-mode-exit" onclick="exitPlayMode()">‚úï Exit (ESC)</button>
        </div>
    </div>

    <script>
        // Global state
        let calibData = {
            min_signal: [],
            max_distance: [],
            manual_max_distance: 1200  // default max distance limit
        };
        let sensorData = {
            signal_level: Array(7).fill(0),
            distance: Array(7).fill(0)
        };

        // WebSerial state
        let serialPort = null;
        let serialReader = null;
        let serialConnected = false;
        let serialRequestId = 0;
        let pendingSerialRequests = new Map();
        let configData = {};
        let presetsData = {};
        let presetNames = [];
        let currentGestureIndex = 0;
        let currentPresetName = '';
        let isDragging = false;
        let dragEdge = null; // 'left', 'right', 'top', 'bottom', 'move'
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartGestureX = 0;
        let dragStartGestureY = 0;
        
        // Undo/Redo state
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 10;
        
        // Gesture creation state
        let isCreatingGesture = false;
        let newGestureStart = null;
        
        // Play mode state
        let isPlayMode = false;
        let playModeCanvas = null;
        let playModeCtx = null;
        let activePlayGestures = [];
        let playModeMouseX = 0;
        let playModeMouseY = 0;
        let playModeSignalPoints = [];
        
        // Audio synthesis state
        let audioContext = null;
        let masterGain = null;
        let activeNotes = new Map(); // Map of note keys to oscillator/gain pairs
        let globalFilter = null; // Global filter for all notes
        let reverbNode = null; // Convolver for reverb
        let dryGain = null; // Dry signal gain
        let wetGain = null; // Wet (reverb) signal gain

        // Dirty flags for YAML files
        let dirtyFlags = {
            calib: false,
            config: false,
            presets: {} // Will store flags for each preset: { 'presetName': true/false }
        };

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            await loadAllFiles();
            setupEventListeners();
            startDirtyCheckTimer();
            startSensorDataPolling();
        });

        // Normalize preset data - ensure CC events have bottom/top/singleValue, ensure CV array exists
        function normalizePresetData(preset) {
            if (!preset || !preset.gestures) return;
            
            preset.gestures.forEach(gesture => {
                // Normalize MIDI events
                if (gesture.midi && Array.isArray(gesture.midi)) {
                    gesture.midi.forEach(event => {
                        if (event.cc !== undefined) {
                            if (event.bottom === undefined) event.bottom = 0;
                            if (event.top === undefined) event.top = 127;
                            if (event.singleValue === undefined) event.singleValue = false;
                        }
                    });
                }
                
                // Ensure CV array exists and normalize CV events
                if (!gesture.cv || !Array.isArray(gesture.cv)) {
                    gesture.cv = [];
                }
                gesture.cv.forEach(event => {
                    if (event.bottom === undefined) event.bottom = -5.0;
                    if (event.top === undefined) event.top = 5.0;
                    if (event.singleValue === undefined) event.singleValue = false;
                });
            });
        }

        // Mark file as dirty
        function markDirty(fileType, presetName = null) {
            if (fileType === 'calib') {
                dirtyFlags.calib = true;
            } else if (fileType === 'config') {
                dirtyFlags.config = true;
            } else if (fileType === 'preset' && presetName) {
                dirtyFlags.presets[presetName] = true;
            }
        }

        // Start dirty check timer (1000 ms) - recursive setTimeout
        function startDirtyCheckTimer() {
            setTimeout(async () => {
                const filesToUpdate = [];
                
                if (dirtyFlags.calib) {
                    filesToUpdate.push({ type: 'calib', data: calibData });
                    dirtyFlags.calib = false;
                }
                
                if (dirtyFlags.config) {
                    filesToUpdate.push({ type: 'config', data: configData });
                    dirtyFlags.config = false;
                }
                
                for (const [presetName, isDirty] of Object.entries(dirtyFlags.presets)) {
                    if (isDirty) {
                        filesToUpdate.push({ type: 'preset', name: presetName, data: presetsData[presetName] });
                        dirtyFlags.presets[presetName] = false;
                    }
                }
                
                // Send POST requests for each changed file and wait for all to complete
                const fetchPromises = filesToUpdate.map(file => {
                    let url, content;
                    if (file.type === 'calib') {
                        url = '/calib.yml';
                        content = jsyaml.dump(file.data, { lineWidth: -1 });
                    } else if (file.type === 'config') {
                        url = '/config.yml';
                        content = jsyaml.dump(file.data, { lineWidth: -1 });
                    } else if (file.type === 'preset') {
                        url = `/presets/${file.name}.yml`;
                        content = jsyaml.dump(file.data, { lineWidth: -1 });
                    }
                    
                    return apiFetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/yaml'
                        },
                        body: content
                    }).then(response => {
                        if (response.ok) {
                            console.log(`Updated ${url}`);
                        } else {
                            console.error(`Failed to update ${url}: ${response.status}`);
                        }
                    }).catch(error => {
                        console.error(`Error updating ${url}:`, error);
                    });
                });
                
                // Wait for all fetch requests to complete before scheduling next check
                await Promise.all(fetchPromises);
                
                // Schedule next check
                startDirtyCheckTimer();
            }, 1000);
        }

        // Load all YAML files
        async function loadAllFiles() {
            try {
                // Load calib.yml
                const calibResponse = await apiFetch('/calib.yml');
                const calibText = await calibResponse.text();
                const loadedCalib = jsyaml.load(calibText) || {};
                // Handle both new format (object) and legacy format (array)
                if (Array.isArray(loadedCalib)) {
                    // Legacy format: just array of min_signal values
                    calibData = {
                        min_signal: loadedCalib,
                        max_distance: Array(7).fill(1000) // Default values
                    };
                } else {
                    // New format: object with min_signal and max_distance
                    calibData = {
                        min_signal: loadedCalib.min_signal || Array(7).fill(0),
                        max_distance: loadedCalib.max_distance || Array(7).fill(1000),
                        manual_max_distance: loadedCalib.manual_max_distance || 1200
                    };
                }
                // Ensure arrays have 7 elements
                while (calibData.min_signal.length < 7) {
                    calibData.min_signal.push(0);
                }
                while (calibData.max_distance.length < 7) {
                    calibData.max_distance.push(1000);
                }
                renderCalibration();

                // Load config.yml
                const configResponse = await apiFetch('/config.yml');
                const configText = await configResponse.text();
                configData = jsyaml.load(configText) || {};
                
                // Load preset files list from /presets endpoint
                const presetsListResponse = await apiFetch('/presets');
                const presetFiles = await presetsListResponse.json();
                for (const file of presetFiles) {
                    const response = await apiFetch(`/presets/${file}`);
                    const text = await response.text();
                    const name = file.replace('.yml', '');
                    presetsData[name] = jsyaml.load(text) || { gestures: [] };
                    normalizePresetData(presetsData[name]);
                    presetNames.push(name);
                }

                // Populate preset selectors
                populatePresetSelectors();
                renderConfig();
                
                // Auto-select default preset
                if (presetNames.includes('default')) {
                    document.getElementById('selectedPreset').value = 'default';
                    currentPresetName = 'default';
                    currentGestureIndex = 0;
                    updateGestureCounter();
                    drawGestures('default');
                    renderMidiEvents();
                    renderCvEvents();
                }
                
                // Initialize history buttons
                updateHistoryButtons();
                
                showStatus('Files loaded successfully', 'success');
            } catch (error) {
                console.error('Error loading files:', error);
                showStatus('Error loading files: ' + error.message, 'error');
            }
        }

        // Render calibration inputs
        function renderCalibration() {
            const grid = document.getElementById('calibGrid');
            grid.innerHTML = '';
            
            // Manual max distance slider
            const manualMaxDistContainer = document.createElement('div');
            manualMaxDistContainer.style.marginBottom = '20px';
            manualMaxDistContainer.style.padding = '10px';
            manualMaxDistContainer.style.border = '1px solid #333333';
            manualMaxDistContainer.style.borderRadius = '4px';
            manualMaxDistContainer.style.backgroundColor = '#0a0a0a';
            
            const manualMaxDistLabel = document.createElement('label');
            manualMaxDistLabel.textContent = 'Manual Max Distance: ';
            manualMaxDistLabel.style.color = '#e0e0e0';
            manualMaxDistLabel.style.fontSize = '12px';
            manualMaxDistLabel.style.marginRight = '10px';
            
            const manualMaxDistValue = document.createElement('span');
            manualMaxDistValue.id = 'manualMaxDistValue';
            manualMaxDistValue.textContent = calibData.manual_max_distance || 1200;
            manualMaxDistValue.style.color = '#ffffff';
            manualMaxDistValue.style.fontSize = '12px';
            manualMaxDistValue.style.fontWeight = 'bold';
            manualMaxDistValue.style.marginRight = '10px';
            manualMaxDistValue.style.minWidth = '50px';
            manualMaxDistValue.style.display = 'inline-block';
            
            const manualMaxDistSlider = document.createElement('input');
            manualMaxDistSlider.type = 'range';
            manualMaxDistSlider.id = 'manualMaxDistSlider';
            manualMaxDistSlider.min = '100';
            manualMaxDistSlider.max = '1200';
            manualMaxDistSlider.value = calibData.manual_max_distance || 1200;
            manualMaxDistSlider.style.width = '200px';
            manualMaxDistSlider.style.marginRight = '10px';
            manualMaxDistSlider.addEventListener('input', () => {
                calibData.manual_max_distance = parseInt(manualMaxDistSlider.value);
                manualMaxDistValue.textContent = calibData.manual_max_distance;
                markDirty('calib');
            });
            
            manualMaxDistContainer.appendChild(manualMaxDistLabel);
            manualMaxDistContainer.appendChild(manualMaxDistValue);
            manualMaxDistContainer.appendChild(manualMaxDistSlider);
            grid.appendChild(manualMaxDistContainer);
            
            // Create four-column layout
            const container = document.createElement('div');
            container.style.display = 'grid';
            container.style.gridTemplateColumns = '1fr 1fr 1fr 1fr';
            container.style.gap = '10px';
            container.style.width = '100%';
            container.style.boxSizing = 'border-box';
            
            // Min Signal column
            const minSignalCol = document.createElement('div');
            minSignalCol.style.display = 'flex';
            minSignalCol.style.flexDirection = 'column';
            minSignalCol.style.gap = '10px';
            minSignalCol.style.width = '100%';
            minSignalCol.style.boxSizing = 'border-box';
            
            const minSignalLabel = document.createElement('h3');
            minSignalLabel.textContent = 'Min Signal';
            minSignalLabel.style.fontSize = '12px';
            minSignalLabel.style.color = '#e0e0e0';
            minSignalLabel.style.marginBottom = '5px';
            minSignalLabel.style.marginTop = '0';
            minSignalLabel.style.fontWeight = '500';
            minSignalCol.appendChild(minSignalLabel);
            
            // Current Signal column
            const currentSignalCol = document.createElement('div');
            currentSignalCol.style.display = 'flex';
            currentSignalCol.style.flexDirection = 'column';
            currentSignalCol.style.gap = '10px';
            currentSignalCol.style.width = '100%';
            currentSignalCol.style.boxSizing = 'border-box';
            
            const currentSignalLabel = document.createElement('h3');
            currentSignalLabel.textContent = 'Current Signal';
            currentSignalLabel.style.fontSize = '12px';
            currentSignalLabel.style.color = '#e0e0e0';
            currentSignalLabel.style.marginBottom = '5px';
            currentSignalLabel.style.marginTop = '0';
            currentSignalLabel.style.fontWeight = '500';
            currentSignalCol.appendChild(currentSignalLabel);
            
            // Max Distance column
            const maxDistanceCol = document.createElement('div');
            maxDistanceCol.style.display = 'flex';
            maxDistanceCol.style.flexDirection = 'column';
            maxDistanceCol.style.gap = '10px';
            maxDistanceCol.style.width = '100%';
            maxDistanceCol.style.boxSizing = 'border-box';
            
            const maxDistanceLabel = document.createElement('h3');
            maxDistanceLabel.textContent = 'Max Distance';
            maxDistanceLabel.style.fontSize = '12px';
            maxDistanceLabel.style.color = '#e0e0e0';
            maxDistanceLabel.style.marginBottom = '5px';
            maxDistanceLabel.style.marginTop = '0';
            maxDistanceLabel.style.fontWeight = '500';
            maxDistanceCol.appendChild(maxDistanceLabel);
            
            // Current Distance column
            const currentDistanceCol = document.createElement('div');
            currentDistanceCol.style.display = 'flex';
            currentDistanceCol.style.flexDirection = 'column';
            currentDistanceCol.style.gap = '10px';
            currentDistanceCol.style.width = '100%';
            currentDistanceCol.style.boxSizing = 'border-box';
            
            const currentDistanceLabel = document.createElement('h3');
            currentDistanceLabel.textContent = 'Current Distance';
            currentDistanceLabel.style.fontSize = '12px';
            currentDistanceLabel.style.color = '#e0e0e0';
            currentDistanceLabel.style.marginBottom = '5px';
            currentDistanceLabel.style.marginTop = '0';
            currentDistanceLabel.style.fontWeight = '500';
            currentDistanceCol.appendChild(currentDistanceLabel);
            
            for (let i = 0; i < 7; i++) {
                // Min Signal input
                const minSignalInput = document.createElement('input');
                minSignalInput.type = 'number';
                minSignalInput.id = `calibMinSignal${i}`;
                minSignalInput.value = calibData.min_signal[i] || 0;
                minSignalInput.style.padding = '6px 8px';
                minSignalInput.style.border = '1px solid #333333';
                minSignalInput.style.borderRadius = '4px';
                minSignalInput.style.fontSize = '12px';
                minSignalInput.style.background = '#0a0a0a';
                minSignalInput.style.color = '#ffffff';
                minSignalInput.style.width = '100%';
                minSignalInput.style.boxSizing = 'border-box';
                minSignalInput.addEventListener('input', () => {
                    calibData.min_signal[i] = parseInt(minSignalInput.value) || 0;
                    markDirty('calib');
                });
                minSignalCol.appendChild(minSignalInput);
                
                // Current Signal display
                const currentSignalDisplay = document.createElement('div');
                currentSignalDisplay.id = `currentSignal${i}`;
                currentSignalDisplay.textContent = sensorData.signal_level[i] || 0;
                currentSignalDisplay.style.padding = '6px 8px';
                currentSignalDisplay.style.border = '1px solid #333333';
                currentSignalDisplay.style.borderRadius = '4px';
                currentSignalDisplay.style.fontSize = '12px';
                currentSignalDisplay.style.backgroundColor = '#1a1a1a';
                currentSignalDisplay.style.color = '#ffffff';
                currentSignalDisplay.style.textAlign = 'center';
                currentSignalDisplay.style.width = '100%';
                currentSignalDisplay.style.boxSizing = 'border-box';
                currentSignalCol.appendChild(currentSignalDisplay);
                
                // Max Distance input
                const maxDistanceInput = document.createElement('input');
                maxDistanceInput.type = 'number';
                maxDistanceInput.id = `calibMaxDistance${i}`;
                maxDistanceInput.value = calibData.max_distance[i] || 1000;
                maxDistanceInput.style.padding = '6px 8px';
                maxDistanceInput.style.border = '1px solid #333333';
                maxDistanceInput.style.borderRadius = '4px';
                maxDistanceInput.style.fontSize = '12px';
                maxDistanceInput.style.background = '#0a0a0a';
                maxDistanceInput.style.color = '#ffffff';
                maxDistanceInput.style.width = '100%';
                maxDistanceInput.style.boxSizing = 'border-box';
                maxDistanceInput.addEventListener('input', () => {
                    calibData.max_distance[i] = parseInt(maxDistanceInput.value) || 1000;
                    markDirty('calib');
                });
                maxDistanceCol.appendChild(maxDistanceInput);
                
                // Current Distance display
                const currentDistanceDisplay = document.createElement('div');
                currentDistanceDisplay.id = `currentDistance${i}`;
                currentDistanceDisplay.textContent = sensorData.distance[i] || 0;
                currentDistanceDisplay.style.padding = '6px 8px';
                currentDistanceDisplay.style.border = '1px solid #333333';
                currentDistanceDisplay.style.borderRadius = '4px';
                currentDistanceDisplay.style.fontSize = '12px';
                currentDistanceDisplay.style.backgroundColor = '#1a1a1a';
                currentDistanceDisplay.style.color = '#ffffff';
                currentDistanceDisplay.style.textAlign = 'center';
                currentDistanceDisplay.style.width = '100%';
                currentDistanceDisplay.style.boxSizing = 'border-box';
                currentDistanceCol.appendChild(currentDistanceDisplay);
            }
            
            container.appendChild(minSignalCol);
            container.appendChild(currentSignalCol);
            container.appendChild(maxDistanceCol);
            container.appendChild(currentDistanceCol);
            grid.appendChild(container);
        }
        
        // Update sensor data displays in the calibration panel
        function updateSensorDisplays() {
            for (let i = 0; i < 7; i++) {
                const signalDisplay = document.getElementById(`currentSignal${i}`);
                const distanceDisplay = document.getElementById(`currentDistance${i}`);
                if (signalDisplay) {
                    signalDisplay.textContent = sensorData.signal_level[i] || 0;
                }
                if (distanceDisplay) {
                    distanceDisplay.textContent = sensorData.distance[i] || 0;
                }
            }
        }

        // Chunked serial write: data queued, one chunk sent per firmware broadcast.
        const SERIAL_CHUNK_SIZE = 100;
        let serialOutBuf = new Uint8Array(0);

        function serialWrite(str) {
            const encoded = new TextEncoder().encode(str);
            const newBuf = new Uint8Array(serialOutBuf.length + encoded.length);
            newBuf.set(serialOutBuf);
            newBuf.set(encoded, serialOutBuf.length);
            serialOutBuf = newBuf;
            return Promise.resolve();
        }

        // Called exactly once per received broadcast line
        function sendNextChunk() {
            if (serialOutBuf.length === 0 || !serialPort?.writable) return;
            const chunk = serialOutBuf.slice(0, SERIAL_CHUNK_SIZE);
            serialOutBuf = serialOutBuf.slice(SERIAL_CHUNK_SIZE);
            const writer = serialPort.writable.getWriter();
            writer.write(chunk).then(() => writer.releaseLock())
                               .catch(e => writer.releaseLock());
        }

        // Fetch wrapper: routes through WebSerial when connected, otherwise HTTP
        function apiFetch(url, options = {}) {
            // Normalize relative URL to absolute
            let normalizedUrl = url;
            if (!normalizedUrl.startsWith('/')) {
                normalizedUrl = '/' + normalizedUrl;
            }

            if (serialConnected) {
                return new Promise((resolve, reject) => {
                    const id = ++serialRequestId;
                    const method = (options.method || 'GET').toUpperCase();

                    let req = { m: method, id: id, u: normalizedUrl };

                    if (options.body && method === 'POST') {
                        // Body comes as YAML text from the page ‚Äî parse to object for JSON transport
                        try {
                            req.b = jsyaml.load(options.body);
                        } catch (e) {
                            try { req.b = JSON.parse(options.body); } catch (e2) { req.b = options.body; }
                        }
                    }

                    const reqStr = JSON.stringify(req);
                    pendingSerialRequests.set(id, resolve);
                    serialWrite(reqStr + '\n');

                    // Timeout: account for chunked TX + firmware processing
                    const txTimeMs = Math.ceil(reqStr.length / SERIAL_CHUNK_SIZE) * 60;
                    const timeoutMs = txTimeMs + (method === 'POST' ? 3000 : 2000);
                    setTimeout(() => {
                        if (pendingSerialRequests.has(id)) {
                            pendingSerialRequests.delete(id);
                            reject(new Error('Serial request timeout for ' + normalizedUrl));
                        }
                    }, timeoutMs);
                });
            }

            return fetch(url, options);
        }

        // Send MIDI CC message
        async function sendMidiCC() {
            const channel = parseInt(document.getElementById('midiCcChannel').value) || 0;
            const cc = parseInt(document.getElementById('midiCcNumber').value) || 0;
            const value = parseInt(document.getElementById('midiCcValue').value) || 0;
            
            if (channel < 0 || channel > 15) {
                alert('Channel must be between 0 and 15');
                return;
            }
            if (cc < 0 || cc > 127) {
                alert('CC number must be between 0 and 127');
                return;
            }
            if (value < 0 || value > 127) {
                alert('Value must be between 0 and 127');
                return;
            }
            
            const body = JSON.stringify({
                type: 'cc',
                channel: channel,
                cc: cc,
                value: value
            });
            
            try {
                const response = await apiFetch('/midi', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: body
                });
                
                if (response && response.ok) {
                    console.log('MIDI CC sent:', { channel, cc, value });
                } else {
                    const text = response ? await response.text() : 'Unknown error';
                    alert('Failed to send MIDI CC: ' + text);
                }
            } catch (error) {
                console.error('Error sending MIDI CC:', error);
                alert('Error sending MIDI CC: ' + error.message);
            }
        }

        // Send MIDI Note On/Off message
        async function sendMidiNote(isOn) {
            const channel = parseInt(document.getElementById('midiNoteChannel').value) || 0;
            const note = parseInt(document.getElementById('midiNoteNumber').value) || 60;
            const velocity = parseInt(document.getElementById('midiNoteVelocity').value) || 100;
            
            if (channel < 0 || channel > 15) {
                alert('Channel must be between 0 and 15');
                return;
            }
            if (note < 0 || note > 127) {
                alert('Note number must be between 0 and 127');
                return;
            }
            if (velocity < 0 || velocity > 127) {
                alert('Velocity must be between 0 and 127');
                return;
            }
            
            const body = JSON.stringify({
                type: 'note',
                channel: channel,
                note: note,
                velocity: velocity,
                on: isOn
            });
            
            try {
                const response = await apiFetch('/midi', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: body
                });
                
                if (response && response.ok) {
                    console.log('MIDI Note ' + (isOn ? 'On' : 'Off') + ' sent:', { channel, note, velocity });
                } else {
                    const text = response ? await response.text() : 'Unknown error';
                    alert('Failed to send MIDI Note: ' + text);
                }
            } catch (error) {
                console.error('Error sending MIDI Note:', error);
                alert('Error sending MIDI Note: ' + error.message);
            }
        }

        // Start polling sensor data (HTTP fallback when serial not connected)
        function startSensorDataPolling() {
            async function pollSensorData() {
                // Skip HTTP polling when WebSerial is connected
                if (!serialConnected) {
                    try {
                        const response = await fetch('/sensor_data');
                        if (response.ok) {
                            const data = await response.json();
                            if (data.signal_level && data.distance) {
                                sensorData.signal_level = data.signal_level;
                                sensorData.distance = data.distance;
                                updateSensorDisplays();
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching sensor data:', error);
                    }
                }
                
                // Schedule next poll (100ms interval)
                setTimeout(pollSensorData, 100);
            }
            
            pollSensorData();
        }

        // WebSerial: connect/disconnect toggle
        async function toggleSerial() {
            if (serialConnected) {
                await disconnectSerial();
            } else {
                await connectSerial();
            }
        }

        async function connectSerial() {
            if (!('serial' in navigator)) {
                alert('WebSerial is not supported in this browser. Use Chrome or Edge.');
                return;
            }

            try {
                serialPort = await navigator.serial.requestPort();
                await serialPort.open({ baudRate: 921600 });

                serialConnected = true;
                const btn = document.getElementById('serialBtn');
                btn.textContent = '‚ö° Disconnect';
                btn.classList.add('connected');
                document.getElementById('recordBtn').style.display = '';
                document.getElementById('calibBtn').style.display = '';

                // Start reading
                readSerialLoop();

                // Reload all data over serial
                loadAllFiles();
            } catch (err) {
                console.error('Serial connect error:', err);
                serialConnected = false;
            }
        }

        async function disconnectSerial() {
            serialConnected = false;

            try {
                if (serialReader) {
                    await serialReader.cancel();
                    serialReader = null;
                }
                if (serialPort) {
                    await serialPort.close();
                    serialPort = null;
                }
            } catch (err) {
                console.error('Serial disconnect error:', err);
            }

            const btn = document.getElementById('serialBtn');
            btn.textContent = '‚ö° Connect Serial';
            btn.classList.remove('connected');

            // Stop recording if active
            if (recording) toggleRecording();
            document.getElementById('recordBtn').style.display = 'none';
            document.getElementById('calibBtn').style.display = 'none';
        }

        async function readSerialLoop() {
            const decoder = new TextDecoderStream();
            const inputDone = serialPort.readable.pipeTo(decoder.writable);
            const inputStream = decoder.readable;
            serialReader = inputStream.getReader();

            let lineBuf = '';
            try {
                while (serialConnected) {
                    const { value, done } = await serialReader.read();
                    if (done) break;
                    if (!value) continue;

                    lineBuf += value;
                    let lines = lineBuf.split('\n');
                    // Keep the last incomplete chunk in the buffer
                    lineBuf = lines.pop();

                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (!trimmed) continue;
                        try {
                            const data = JSON.parse(trimmed);
                            if (data.d && data.s) {
                                sensorData.distance = data.d;
                                sensorData.signal_level = data.s;
                                updateSensorDisplays();

                                // Handle calibration status from device
                                if (data.cal !== undefined) {
                                    handleCalibStatus(data.cal);
                                }

                                // Process signal: Part 1 (spatial) ‚Üí Part 2 (temporal)
                                const rawPoints = signalProcessor.getRawPoints(data.s, data.d);
                                const filteredPoints = signalProcessor.getFilteredPoints(rawPoints);
                                
                                // Get processed points from device (for yellow display)
                                const devicePoints = data.p ? data.p.map(p => ({
                                    x: p.x,
                                    y: p.y,
                                    dist: p.dist
                                })) : [];
                                
                                if (isPlayMode) {
                                    updatePlayModeWithSignalPoints(filteredPoints);
                                } else {
                                    drawGestures(currentPresetName);
                                    drawSignalPoints(rawPoints, filteredPoints, devicePoints);
                                }
                                recordSample(data.s, data.d, filteredPoints);

                                sendNextChunk();
                            } else if (data.id !== undefined && data.c !== undefined) {
                                // Response to a serial request
                                const cb = pendingSerialRequests.get(data.id);
                                if (cb) {
                                    pendingSerialRequests.delete(data.id);
                                    const bodyStr = data.b !== undefined ? JSON.stringify(data.b) : '';
                                    cb({
                                        ok: data.c >= 200 && data.c < 300,
                                        status: data.c,
                                        text: () => Promise.resolve(bodyStr),
                                        json: () => Promise.resolve(data.b)
                                    });
                                }
                            }
                        } catch (e) {
                            // ignore parse errors
                        }
                    }
                }
            } catch (err) {
                if (serialConnected) {
                    console.error('Serial read error:', err);
                }
            } finally {
                serialReader.releaseLock();
                serialReader = null;
            }
        }

        // Populate preset selectors
        function populatePresetSelectors() {
            const defaultPresetSelect = document.getElementById('defaultPreset');
            const selectedPresetSelect = document.getElementById('selectedPreset');

            // Clear existing options except the first placeholder
            while (defaultPresetSelect.options.length > 1) {
                defaultPresetSelect.remove(1);
            }
            while (selectedPresetSelect.options.length > 1) {
                selectedPresetSelect.remove(1);
            }

            // Add preset options
            presetNames.forEach(name => {
                const option1 = document.createElement('option');
                option1.value = name;
                option1.textContent = name;
                defaultPresetSelect.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = name;
                option2.textContent = name;
                selectedPresetSelect.appendChild(option2);
            });
        }

        // Render config inputs
        function renderConfig() {
            document.getElementById('defaultPreset').value = configData.preset || '';
            document.getElementById('color1').value = configData.color1 || '#FE3A86';
            document.getElementById('color2').value = configData.color2 || '#7742ff';
            document.getElementById('color1Picker').value = configData.color1 || '#FE3A86';
            document.getElementById('color2Picker').value = configData.color2 || '#7742ff';
            document.getElementById('wifiSsid').value = configData.wifi_ssid || '';
            document.getElementById('wifiPassword').value = configData.wifi_password || '';
            document.getElementById('wifiApSsid').value = configData.wifi_ap_ssid || '';
            document.getElementById('wifiApPassword').value = configData.wifi_ap_password || '';
            document.getElementById('distanceMinAvgSpeed').value = (configData.distance_min_avg_speed !== undefined && configData.distance_min_avg_speed !== null) ? configData.distance_min_avg_speed : 2;
            document.getElementById('distanceMaxAvgSpeed').value = (configData.distance_max_avg_speed !== undefined && configData.distance_max_avg_speed !== null) ? configData.distance_max_avg_speed : 8;
            document.getElementById('distanceAvgResetThreshold').value = (configData.distance_avg_reset_threshold !== undefined && configData.distance_avg_reset_threshold !== null) ? configData.distance_avg_reset_threshold : 100;
            document.getElementById('xAvgSpeed').value = (configData.x_avg_speed !== undefined && configData.x_avg_speed !== null) ? configData.x_avg_speed : 50;
            document.getElementById('validStreakThreshold').value = (configData.valid_streak_threshold !== undefined && configData.valid_streak_threshold !== null) ? configData.valid_streak_threshold : 5;
            updateGradient();
        }

        // Update gradient preview
        function updateGradient() {
            const color1 = document.getElementById('color1').value;
            const color2 = document.getElementById('color2').value;
            const preview = document.getElementById('gradientPreview');
            preview.style.background = `linear-gradient(to right, ${color1}, ${color2})`;
        }

        // Signal processing class ‚Äî lightweight hand tracking
        // Split into two stages:
        //   Part 1 (getRawPoints): spatial processing only ‚Äî region detection, weighted CoM.
        //           Returns raw points with relative X/Y and signal strength. No temporal smoothing.
        //   Part 2 (getFilteredPoints): validity check, proximity slot matching, EMA smoothing, hold.
        //           Returns smooth filtered points.
        class SignalProcessor {
            constructor() {
                this.CH_COUNT = 7;
                this.MAX_REGIONS = 2;

                // Fallback thresholds (used when calibration is not yet done)
                this.DEFAULT_NOISE_FLOOR = 30;
                this.DEFAULT_MAX_DIST = 400;

                this.DEFAULT_SMOOTH = 0.4;  // fallback EMA (0 = instant, 1 = freeze)
                this.HOLD_FRAMES = 3;       // keep point visible after hand leaves

                // Per-slot tracked state (slot = persistent identity for a hand)
                this.slotX = new Float32Array(this.MAX_REGIONS);
                this.slotY = new Float32Array(this.MAX_REGIONS);     // relative Y (0-1)
                this.slotDist = new Float32Array(this.MAX_REGIONS);  // raw distance mm (for gestures)
                this.slotActive = new Uint8Array(this.MAX_REGIONS);  // 0/1
                this.slotHold = new Uint8Array(this.MAX_REGIONS);
            }

            // ---- Part 1: Spatial processing (no temporal smoothing) ----
            // Returns: [{ x, y, dist, strength, validSignal, validDistance }, ...]
            //   x: 0-1 (0 = sensor 6, 1 = sensor 0)
            //   y: relative distance (0-1, where 1 = maxDist-100; can exceed 1)
            //   dist: raw weighted average distance in mm
            //   strength: relative signal (>0 if above calibration, <0 if below)
            //   validSignal: true if signal above calibration threshold
            //   validDistance: true if distance within calibration range
            getRawPoints(signal, distance) {
                const CH = this.CH_COUNT;
                const MR = this.MAX_REGIONS;
                const minSig = calibData.min_signal || [];
                const maxDist = calibData.max_distance || [];
                const hasCalib = minSig.length >= CH && minSig.some(v => v > 0);

                // Per-channel thresholds
                const noiseFloors = new Float32Array(CH);
                const maxDists = new Float32Array(CH);
                const manualMaxDist = calibData.manual_max_distance || 1200;
                for (let i = 0; i < CH; i++) {
                    noiseFloors[i] = hasCalib ? (minSig[i] || 0) : this.DEFAULT_NOISE_FLOOR;
                    const rawMaxDist = hasCalib ? (maxDist[i] || 1000) : this.DEFAULT_MAX_DIST;
                    // Apply manual_max_distance limit: min(max_distance[i], manual_max_distance) - 100
                    const cappedMaxDist = Math.min(rawMaxDist, manualMaxDist);
                    maxDists[i] = Math.max(cappedMaxDist - 100, 0);
                }

                // Per-channel weights: signal - noiseFloor (only positive ‚Üí active channel)
                const weights = new Float32Array(CH);
                let totalWeight = 0;
                for (let i = 0; i < CH; i++) {
                    if (signal[i] > noiseFloors[i]) {
                        weights[i] = signal[i] - noiseFloors[i];
                        totalWeight += weights[i];
                    }
                }

                const rawPoints = [];
                if (totalWeight <= 0) return rawPoints;

                // Find contiguous regions of active channels
                const regions = [];
                let region = [];
                for (let i = 0; i < CH; i++) {
                    if (weights[i] > 0) {
                        region.push(i);
                    } else if (region.length > 0) {
                        regions.push(region);
                        region = [];
                    }
                }
                if (region.length > 0) regions.push(region);

                const count = Math.min(regions.length, MR);

                for (let r = 0; r < count; r++) {
                    const reg = regions[r];
                    let wSum = 0, wXs = 0, wDs = 0, wMaxD = 0;
                    for (const i of reg) {
                        wSum += weights[i];
                        wXs += i * weights[i];
                        wDs += distance[i] * weights[i];
                        wMaxD += maxDists[i] * weights[i];
                    }
                    const x = 1.0 - (wXs / wSum) / 6.0;
                    const dist = wDs / wSum;
                    const refMaxDist = wMaxD / wSum;
                    const y = refMaxDist > 0 ? dist / refMaxDist : 0;
                    // strength: average (signal - noiseFloor) per channel in region
                    const strength = wSum / reg.length;

                    rawPoints.push({
                        x,
                        y,
                        dist,
                        strength,
                        validSignal: true,        // by construction (region = above-threshold channels)
                        validDistance: dist < refMaxDist
                    });
                }
                return rawPoints;
            }

            // ---- Part 2: Validity check + temporal smoothing ----
            // Input: raw points from getRawPoints()
            // Returns: [{ x, y, dist }, ...]  (smoothed, only valid points)
            getFilteredPoints(rawPoints) {
                const MR = this.MAX_REGIONS;

                // Only valid raw points enter the filter
                const valid = rawPoints.filter(p => p.validSignal && p.validDistance);
                const count = Math.min(valid.length, MR);

                if (count > 0) {
                    // Proximity-based slot matching
                    const usedSlots = new Set();
                    const usedRegions = new Set();
                    const assignments = new Map();

                    const activeSlots = [];
                    for (let si = 0; si < MR; si++) {
                        if (this.slotActive[si]) activeSlots.push(si);
                    }

                    if (activeSlots.length > 0) {
                        const pairs = [];
                        for (let ri = 0; ri < count; ri++) {
                            for (const si of activeSlots) {
                                pairs.push({ d: Math.abs(valid[ri].x - this.slotX[si]), ri, si });
                            }
                        }
                        pairs.sort((a, b) => a.d - b.d);
                        for (const { ri, si } of pairs) {
                            if (usedRegions.has(ri) || usedSlots.has(si)) continue;
                            assignments.set(ri, si);
                            usedRegions.add(ri);
                            usedSlots.add(si);
                        }
                    }

                    for (let ri = 0; ri < count; ri++) {
                        if (!usedRegions.has(ri)) {
                            for (let si = 0; si < MR; si++) {
                                if (!usedSlots.has(si)) {
                                    assignments.set(ri, si);
                                    usedSlots.add(si);
                                    usedRegions.add(ri);
                                    break;
                                }
                            }
                        }
                    }

                    // EMA smoothing
                    const smooth = (configData.x_avg_speed !== undefined && configData.x_avg_speed !== null)
                        ? configData.x_avg_speed / 100.0
                        : this.DEFAULT_SMOOTH;

                    for (const [ri, si] of assignments) {
                        const pt = valid[ri];
                        if (this.slotActive[si]) {
                            this.slotX[si] = this.slotX[si] * smooth + pt.x * (1 - smooth);
                            this.slotY[si] = this.slotY[si] * smooth + pt.y * (1 - smooth);
                            this.slotDist[si] = this.slotDist[si] * smooth + pt.dist * (1 - smooth);
                        } else {
                            this.slotX[si] = pt.x;
                            this.slotY[si] = pt.y;
                            this.slotDist[si] = pt.dist;
                        }
                        this.slotActive[si] = 1;
                        this.slotHold[si] = this.HOLD_FRAMES;
                    }

                    for (let si = 0; si < MR; si++) {
                        if (!usedSlots.has(si) && this.slotActive[si]) {
                            if (this.slotHold[si] > 0) this.slotHold[si]--;
                            else this.slotActive[si] = 0;
                        }
                    }
                } else {
                    for (let si = 0; si < MR; si++) {
                        if (this.slotActive[si]) {
                            if (this.slotHold[si] > 0) this.slotHold[si]--;
                            else this.slotActive[si] = 0;
                        }
                    }
                }

                const points = [];
                for (let si = 0; si < MR; si++) {
                    if (this.slotActive[si]) {
                        points.push({ x: this.slotX[si], y: this.slotY[si], dist: this.slotDist[si] });
                    }
                }
                return points;
            }
        }

        const signalProcessor = new SignalProcessor();

        // ---- Recording ----
        let recording = false;
        let recordData = [];
        let recordStartTime = 0;

        function toggleRecording() {
            if (!recording) {
                // Start
                recording = true;
                recordData = [];
                recordStartTime = performance.now();
                const btn = document.getElementById('recordBtn');
                btn.classList.add('recording');
                btn.textContent = '‚èπ Stop';
            } else {
                // Stop & download
                recording = false;
                const btn = document.getElementById('recordBtn');
                btn.classList.remove('recording');
                btn.textContent = '‚è∫ Record';
                downloadRecording();
            }
        }

        function recordSample(signal, distance, points) {
            if (!recording) return;
            const t = Math.round(performance.now() - recordStartTime);
            recordData.push(JSON.stringify({ t, in: { s: signal, d: distance }, out: points }));
        }

        function recordEvent(obj) {
            if (!recording) return;
            const t = Math.round(performance.now() - recordStartTime);
            recordData.push(JSON.stringify({ t, event: obj }));
        }

        function downloadRecording() {
            if (recordData.length === 0) return;
            const blob = new Blob([recordData.join('\n') + '\n'], { type: 'application/jsonl' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const now = new Date();
            const ts = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `quray-recording-${ts}.jsonl`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ---- Device calibration ----
        let calibrationPending = false;

        async function startCalibration() {
            if (calibrationPending) return;
            calibrationPending = true;
            const btn = document.getElementById('calibBtn');
            btn.classList.remove('calibrated');
            btn.classList.add('calibrating');
            btn.textContent = 'üéØ ...';
            try {
                await apiFetch('/calibrate', { method: 'POST' });
                recordEvent({ type: 'calib_start' });
            } catch (e) {
                calibrationPending = false;
                btn.classList.remove('calibrating');
                btn.textContent = 'üéØ Calibrate';
            }
        }

        function handleCalibStatus(cal) {
            const btn = document.getElementById('calibBtn');
            if (!btn) return;
            if (cal && cal !== 'done' && typeof cal === 'string' && cal.includes('/')) {
                // In progress: "12/64"
                btn.classList.remove('calibrated');
                btn.classList.add('calibrating');
                btn.textContent = 'üéØ ' + cal;
            } else if (cal === 'done') {
                if (calibrationPending) {
                    calibrationPending = false;
                    btn.classList.remove('calibrating');
                    btn.classList.add('calibrated');
                    btn.textContent = 'üéØ Calibrated';
                    // Fetch updated calibration from device
                    loadCalibFile();
                }
            }
        }

        async function loadCalibFile() {
            try {
                const resp = await apiFetch('/calib.yml');
                const text = typeof resp === 'string' ? resp : await resp.text();
                const parsed = jsyaml.load(text);
                if (parsed && parsed.min_signal) {
                    calibData.min_signal = parsed.min_signal;
                    calibData.max_distance = parsed.max_distance;
                    calibData.manual_max_distance = parsed.manual_max_distance || 1200;
                    renderCalibration();
                    recordEvent({
                        type: 'calib_done',
                        min_signal: parsed.min_signal,
                        max_distance: parsed.max_distance
                    });
                }
            } catch (e) { /* ignore */ }
        }

        // Draw detected points on the gesture canvas
        // rawPoints: Part 1 output (colored by validity)
        // filteredPoints: Part 2 output (green)
        function drawSignalPoints(rawPoints, filteredPoints, devicePoints) {
            const canvas = document.getElementById('gestureCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            // ---- Processed points from device (yellow) ----
            // These are the points displayed on device screen (coordinates 0-1, y can be >1)
            for (const pt of devicePoints) {
                const cx = pt.x * canvas.width;
                // y is relative (0-1, can be >1 if distance > calibration)
                // Canvas Y: 0 at top, max_distance at bottom, so y=0 maps to bottom, y=1 maps to top
                // Use pt.y directly as it's already calculated relative value
                const cy = Math.max(0, canvas.height * (1 - pt.y));

                // Outer glow
                ctx.beginPath();
                ctx.arc(cx, cy, 12, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 68, 0.25)';
                ctx.fill();

                // Inner dot
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff44';
                ctx.fill();

                // Crosshair
                ctx.strokeStyle = 'rgba(255, 255, 68, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx - 15, cy);
                ctx.lineTo(cx + 15, cy);
                ctx.moveTo(cx, cy - 15);
                ctx.lineTo(cx, cy + 15);
                ctx.stroke();
            }

            // ---- Filtered points from JavaScript processing (green) ----
            for (const pt of filteredPoints) {
                const cx = pt.x * canvas.width;
                // y is relative (0-1), convert to canvas coordinates
                // Canvas Y: 0 at top, 700mm at bottom, so y=0 maps to bottom, y=1 maps to top
                const cy = Math.max(0, canvas.height * (1 - pt.y));

                // Outer glow
                ctx.beginPath();
                ctx.arc(cx, cy, 12, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(68, 255, 68, 0.25)';
                ctx.fill();

                // Inner dot
                ctx.beginPath();
                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#44ff44';
                ctx.fill();

                // Crosshair
                ctx.strokeStyle = 'rgba(68, 255, 68, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx - 15, cy);
                ctx.lineTo(cx + 15, cy);
                ctx.moveTo(cx, cy - 15);
                ctx.lineTo(cx, cy + 15);
                ctx.stroke();
            }
        }

        // Draw gestures on canvas
        function drawGestures(presetName) {
            if (!presetName || !presetsData[presetName]) return;

            const canvas = document.getElementById('gestureCanvas');
            const ctx = canvas.getContext('2d');
            const preset = presetsData[presetName];

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            
            // Vertical lines (X axis: 0 to 1)
            for (let i = 0; i <= 7; i++) {
                const x = (canvas.width / 7) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines (Y axis: 0 to 700)
            for (let i = 0; i <= 7; i++) {
                const y = canvas.height - (canvas.height / 700) * i * 100;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw axis labels
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '12px sans-serif';
            
            // X axis labels
            ctx.fillText('X: 0.0', 5, canvas.height - 5);
            ctx.fillText('1.0', canvas.width - 25, canvas.height - 5);
            
            // Y axis labels
            ctx.fillText('Y: 0', 5, canvas.height - 15);
            for (let i = 1; i <= 7; i++) {
                const y = canvas.height - (canvas.height / 700) * i * 100;
                ctx.fillText(`${i * 100}`, 5, y + 5);
            }

            // Draw gestures
            if (preset.gestures && Array.isArray(preset.gestures)) {
                preset.gestures.forEach((gesture, index) => {
                    if (gesture.position && Array.isArray(gesture.position) && gesture.position.length >= 5) {
                        const [active, xMin, yMin, xMax, yMax] = gesture.position;
                        
                        if (!active) return;

                        // Convert coordinates (Y axis is inverted)
                        const x1 = xMin * canvas.width;
                        const x2 = xMax * canvas.width;
                        const y1 = canvas.height - (yMax / 700 * canvas.height);
                        const y2 = canvas.height - (yMin / 700 * canvas.height);

                        const width = x2 - x1;
                        const height = y2 - y1;

                        const isSelected = index === currentGestureIndex;
                        const hue = index * 360 / preset.gestures.length;

                        // Draw rectangle with semi-transparent fill
                        ctx.fillStyle = isSelected 
                            ? `hsla(${hue}, 70%, 60%, 0.6)` 
                            : `hsla(${hue}, 10%, 50%, 0.15)`;
                        ctx.fillRect(x1, y1, width, height);

                        // Draw border
                        ctx.strokeStyle = isSelected 
                            ? `hsla(${hue}, 70%, 40%, 1)` 
                            : `hsla(${hue}, 10%, 40%, 0.4)`;
                        ctx.lineWidth = isSelected ? 3 : 1;
                        ctx.strokeRect(x1, y1, width, height);

                        // Draw label
                        ctx.fillStyle = isSelected ? '#ffffff' : '#999';
                        ctx.font = isSelected ? 'bold 16px sans-serif' : '12px sans-serif';
                        ctx.fillText(`G${index + 1}`, x1 + 5, y1 + 20);

                        // Draw coordinates for selected gesture
                        if (isSelected) {
                            ctx.font = '11px monospace';
                            ctx.fillStyle = '#ffffff';
                            
                            // Bottom left corner - start coordinates (x_min, y_min)
                            const startCoords = `${xMin.toFixed(2)}, ${yMin.toFixed(0)}`;
                            ctx.fillText(startCoords, x1 + 5, y2 - 5);
                            
                            // Top right corner - end coordinates (x_max, y_max)
                            const endCoords = `${xMax.toFixed(2)}, ${yMax.toFixed(0)}`;
                            const endCoordsWidth = ctx.measureText(endCoords).width;
                            ctx.fillText(endCoords, x2 - endCoordsWidth - 5, y1 + 15);
                        }
                    }
                });
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Color picker sync
            document.getElementById('color1').addEventListener('input', (e) => {
                document.getElementById('color1Picker').value = e.target.value;
                configData.color1 = e.target.value;
                markDirty('config');
                updateGradient();
            });

            document.getElementById('color1Picker').addEventListener('input', (e) => {
                document.getElementById('color1').value = e.target.value;
                configData.color1 = e.target.value;
                markDirty('config');
                updateGradient();
            });

            document.getElementById('color2').addEventListener('input', (e) => {
                document.getElementById('color2Picker').value = e.target.value;
                configData.color2 = e.target.value;
                markDirty('config');
                updateGradient();
            });

            document.getElementById('color2Picker').addEventListener('input', (e) => {
                document.getElementById('color2').value = e.target.value;
                configData.color2 = e.target.value;
                markDirty('config');
                updateGradient();
            });

            // Preset selection
            document.getElementById('selectedPreset').addEventListener('change', (e) => {
                currentPresetName = e.target.value;
                currentGestureIndex = 0;
                
                // Clear history when switching presets
                undoStack = [];
                redoStack = [];
                updateHistoryButtons();
                
                updateGestureCounter();
                drawGestures(currentPresetName);
                renderMidiEvents();
                renderCvEvents();
            });

            // Config fields change handlers
            document.getElementById('defaultPreset').addEventListener('change', (e) => {
                configData.preset = e.target.value;
                markDirty('config');
            });

            document.getElementById('wifiSsid').addEventListener('input', (e) => {
                configData.wifi_ssid = e.target.value;
                markDirty('config');
            });

            document.getElementById('wifiPassword').addEventListener('input', (e) => {
                configData.wifi_password = e.target.value;
                markDirty('config');
            });

            document.getElementById('wifiApSsid').addEventListener('input', (e) => {
                configData.wifi_ap_ssid = e.target.value;
                markDirty('config');
            });

            document.getElementById('wifiApPassword').addEventListener('input', (e) => {
                configData.wifi_ap_password = e.target.value;
                markDirty('config');
            });

            document.getElementById('distanceMinAvgSpeed').addEventListener('input', (e) => {
                configData.distance_min_avg_speed = parseInt(e.target.value) || 2;
                markDirty('config');
            });

            document.getElementById('distanceMaxAvgSpeed').addEventListener('input', (e) => {
                configData.distance_max_avg_speed = parseInt(e.target.value) || 8;
                markDirty('config');
            });

            document.getElementById('distanceAvgResetThreshold').addEventListener('input', (e) => {
                configData.distance_avg_reset_threshold = parseInt(e.target.value) || 100;
                markDirty('config');
            });

            document.getElementById('xAvgSpeed').addEventListener('input', (e) => {
                configData.x_avg_speed = parseInt(e.target.value) || 50;
                markDirty('config');
            });

            document.getElementById('validStreakThreshold').addEventListener('input', (e) => {
                configData.valid_streak_threshold = parseInt(e.target.value) || 5;
                markDirty('config');
            });

            // Canvas event handlers
            const canvas = document.getElementById('gestureCanvas');
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', handleCanvasMouseLeave);

            // Keyboard shortcuts for undo/redo and gesture creation
            document.addEventListener('keydown', (e) => {
                // Cancel gesture creation with Escape
                if (e.key === 'Escape' && isCreatingGesture) {
                    e.preventDefault();
                    cancelCreateGesture();
                    return;
                }
                
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    redo();
                }
            });

            // MIDI CC value slider update display
            const midiCcValueSlider = document.getElementById('midiCcValue');
            const midiCcValueDisplay = document.getElementById('midiCcValueDisplay');
            if (midiCcValueSlider && midiCcValueDisplay) {
                midiCcValueSlider.addEventListener('input', (e) => {
                    midiCcValueDisplay.textContent = e.target.value;
                });
                // Also send CC when slider is moved (optional - can be removed if only button should send)
                // midiCcValueSlider.addEventListener('input', sendMidiCC);
            }
        }

        // Save current preset state to history
        function saveHistory() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            // Create a deep copy of the current preset
            const state = {
                presetName: currentPresetName,
                preset: JSON.parse(JSON.stringify(presetsData[currentPresetName])),
                gestureIndex: currentGestureIndex
            };
            
            // Add to undo stack
            undoStack.push(state);
            
            // Limit stack size
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            redoStack = [];
            
            updateHistoryButtons();
        }

        // Undo last action
        function undo() {
            if (undoStack.length === 0) return;
            
            // Save current state to redo stack
            if (currentPresetName && presetsData[currentPresetName]) {
                const currentState = {
                    presetName: currentPresetName,
                    preset: JSON.parse(JSON.stringify(presetsData[currentPresetName])),
                    gestureIndex: currentGestureIndex
                };
                redoStack.push(currentState);
                
                if (redoStack.length > MAX_HISTORY) {
                    redoStack.shift();
                }
            }
            
            // Restore previous state
            const state = undoStack.pop();
            if (state) {
                presetsData[state.presetName] = JSON.parse(JSON.stringify(state.preset));
                currentPresetName = state.presetName;
                currentGestureIndex = state.gestureIndex;
                
                // Update UI
                document.getElementById('selectedPreset').value = currentPresetName;
                updateGestureCounter();
                drawGestures(currentPresetName);
                updateHistoryButtons();
                renderMidiEvents();
                renderCvEvents();
                
                showStatus('Undo successful', 'success');
            }
        }

        // Redo last undone action
        function redo() {
            if (redoStack.length === 0) return;
            
            // Save current state to undo stack
            if (currentPresetName && presetsData[currentPresetName]) {
                const currentState = {
                    presetName: currentPresetName,
                    preset: JSON.parse(JSON.stringify(presetsData[currentPresetName])),
                    gestureIndex: currentGestureIndex
                };
                undoStack.push(currentState);
                
                if (undoStack.length > MAX_HISTORY) {
                    undoStack.shift();
                }
            }
            
            // Restore redo state
            const state = redoStack.pop();
            if (state) {
                presetsData[state.presetName] = JSON.parse(JSON.stringify(state.preset));
                currentPresetName = state.presetName;
                currentGestureIndex = state.gestureIndex;
                
                // Update UI
                document.getElementById('selectedPreset').value = currentPresetName;
                updateGestureCounter();
                drawGestures(currentPresetName);
                updateHistoryButtons();
                renderMidiEvents();
                renderCvEvents();
                
                showStatus('Redo successful', 'success');
            }
        }

        // Update history button states
        function updateHistoryButtons() {
            const undoButton = document.getElementById('undoButton');
            const redoButton = document.getElementById('redoButton');
            
            if (undoButton) {
                undoButton.disabled = undoStack.length === 0;
            }
            if (redoButton) {
                redoButton.disabled = redoStack.length === 0;
            }
        }

        // Check if point is inside any gesture
        function getGestureAtPoint(x, y) {
            if (!currentPresetName || !presetsData[currentPresetName]) return -1;

            const canvas = document.getElementById('gestureCanvas');
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || !Array.isArray(preset.gestures)) return -1;

            // Check each gesture to see if point is inside (reverse order for top-most)
            for (let i = preset.gestures.length - 1; i >= 0; i--) {
                const gesture = preset.gestures[i];
                if (gesture.position && Array.isArray(gesture.position) && gesture.position.length >= 5) {
                    const [active, xMin, yMin, xMax, yMax] = gesture.position;
                    
                    if (!active) continue;

                    // Convert gesture coordinates to canvas coordinates
                    const x1 = xMin * canvas.width;
                    const x2 = xMax * canvas.width;
                    const y1 = canvas.height - (yMax / 700 * canvas.height);
                    const y2 = canvas.height - (yMin / 700 * canvas.height);

                    // Check if point is within this gesture's bounds
                    if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
                        return i;
                    }
                }
            }
            return -1;
        }

        // Get edge near point for selected gesture
        function getEdgeNearPoint(x, y, tolerance = 10) {
            if (!currentPresetName || !presetsData[currentPresetName]) return null;
            
            const canvas = document.getElementById('gestureCanvas');
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || !Array.isArray(preset.gestures)) return null;

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture || !gesture.position || gesture.position.length < 5) return null;

            const [active, xMin, yMin, xMax, yMax] = gesture.position;
            if (!active) return null;

            // Convert gesture coordinates to canvas coordinates
            const x1 = xMin * canvas.width;
            const x2 = xMax * canvas.width;
            const y1 = canvas.height - (yMax / 700 * canvas.height);
            const y2 = canvas.height - (yMin / 700 * canvas.height);

            // Check proximity to edges
            const nearLeft = Math.abs(x - x1) < tolerance && y >= y1 - tolerance && y <= y2 + tolerance;
            const nearRight = Math.abs(x - x2) < tolerance && y >= y1 - tolerance && y <= y2 + tolerance;
            const nearTop = Math.abs(y - y1) < tolerance && x >= x1 - tolerance && x <= x2 + tolerance;
            const nearBottom = Math.abs(y - y2) < tolerance && x >= x1 - tolerance && x <= x2 + tolerance;

            if (nearLeft) return 'left';
            if (nearRight) return 'right';
            if (nearTop) return 'top';
            if (nearBottom) return 'bottom';

            return null;
        }

        // Handle canvas mouse move
        function handleCanvasMouseMove(event) {
            const canvas = document.getElementById('gestureCanvas');
            const rect = canvas.getBoundingClientRect();
            
            // Get mouse coordinates relative to canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            // If creating gesture and dragging, draw preview
            if (isCreatingGesture && isDragging && newGestureStart) {
                drawGestureCreationPreview(newGestureStart.x, newGestureStart.y, x, y);
                return;
            }

            if (isDragging && dragEdge) {
                // Update gesture boundary or move gesture
                if (dragEdge === 'move') {
                    moveGesture(x, y);
                } else {
                    updateGestureBoundary(x, y);
                }
                drawGestures(currentPresetName);
                return;
            }

            // Don't change cursor in creation mode
            if (isCreatingGesture) {
                return;
            }

            // Check if near edge of selected gesture
            const edge = getEdgeNearPoint(x, y);
            if (edge) {
                if (edge === 'left' || edge === 'right') {
                    canvas.style.cursor = 'ew-resize';
                } else {
                    canvas.style.cursor = 'ns-resize';
                }
            } else {
                const gestureIndex = getGestureAtPoint(x, y);
                if (gestureIndex === currentGestureIndex) {
                    canvas.style.cursor = 'move';
                } else if (gestureIndex !== -1) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        // Draw preview rectangle while creating gesture
        function drawGestureCreationPreview(x1, y1, x2, y2) {
            // Redraw existing gestures
            drawGestures(currentPresetName);
            
            const canvas = document.getElementById('gestureCanvas');
            const ctx = canvas.getContext('2d');
            
            // Draw preview rectangle
            const x = Math.min(x1, x2);
            const y = Math.min(y1, y2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            
            // Semi-transparent fill
            ctx.fillStyle = 'rgba(119, 66, 255, 0.3)';
            ctx.fillRect(x, y, width, height);
            
            // Dashed border
            ctx.strokeStyle = '#7742ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(x, y, width, height);
            ctx.setLineDash([]);
        }

        // Handle canvas mouse down
        function handleCanvasMouseDown(event) {
            const canvas = document.getElementById('gestureCanvas');
            const rect = canvas.getBoundingClientRect();
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            // If in creation mode, start drawing
            if (isCreatingGesture) {
                newGestureStart = { x, y };
                isDragging = true;
                event.preventDefault();
                return;
            }

            // Check if clicking on edge
            const edge = getEdgeNearPoint(x, y);
            if (edge) {
                saveHistory(); // Save state before changing
                isDragging = true;
                dragEdge = edge;
                dragStartX = x;
                dragStartY = y;
                event.preventDefault();
                return;
            }

            // Check if clicking on gesture
            const gestureIndex = getGestureAtPoint(x, y);
            if (gestureIndex !== -1) {
                // If clicking on currently selected gesture, start move
                if (gestureIndex === currentGestureIndex && currentPresetName && presetsData[currentPresetName]) {
                    const preset = presetsData[currentPresetName];
                    const gesture = preset.gestures[currentGestureIndex];
                    if (gesture && gesture.position && gesture.position.length >= 5) {
                        saveHistory(); // Save state before moving
                        isDragging = true;
                        dragEdge = 'move';
                        dragStartX = x;
                        dragStartY = y;
                        dragStartGestureX = gesture.position[1]; // xMin
                        dragStartGestureY = gesture.position[2]; // yMin
                        event.preventDefault();
                        return;
                    }
                }
                
                // Otherwise select the gesture
                currentGestureIndex = gestureIndex;
                updateGestureCounter();
                drawGestures(currentPresetName);
                renderMidiEvents();
                renderCvEvents();
            }
        }

        // Handle canvas mouse up
        function handleCanvasMouseUp(event) {
            if (isCreatingGesture && isDragging && newGestureStart) {
                const canvas = document.getElementById('gestureCanvas');
                const rect = canvas.getBoundingClientRect();
                
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                
                // Complete the gesture
                completeCreateGesture(newGestureStart.x, newGestureStart.y, x, y);
            }
            
            isDragging = false;
            dragEdge = null;
        }

        // Handle canvas mouse leave
        function handleCanvasMouseLeave(event) {
            // Don't cancel gesture creation on mouse leave
            if (!isCreatingGesture) {
                isDragging = false;
                dragEdge = null;
            }
        }

        // Apply snapping to a value
        function applySnapping(value, isXAxis) {
            const snapTolerance = isXAxis ? 0.005 : 10; // 2.5% for X, 15 units for Y
            
            if (isXAxis) {
                // X axis snapping - screen edges and other gestures
                const snapPoints = [0, 1.0];
                
                // Add boundaries of other gestures for X axis
                if (currentPresetName && presetsData[currentPresetName]) {
                    const preset = presetsData[currentPresetName];
                    if (preset.gestures && Array.isArray(preset.gestures)) {
                        preset.gestures.forEach((g, idx) => {
                            if (idx !== currentGestureIndex && g.position && g.position.length >= 5 && g.position[0]) {
                                snapPoints.push(g.position[1]); // xMin
                                snapPoints.push(g.position[3]); // xMax
                            }
                        });
                    }
                }
                
                for (let snapPoint of snapPoints) {
                    if (Math.abs(value - snapPoint) < snapTolerance) {
                        return snapPoint;
                    }
                }
            } else {
                // Y axis snapping - screen edges and other gestures
                const snapPoints = [0, 700];
                
                // Add boundaries of other gestures for Y axis
                if (currentPresetName && presetsData[currentPresetName]) {
                    const preset = presetsData[currentPresetName];
                    if (preset.gestures && Array.isArray(preset.gestures)) {
                        preset.gestures.forEach((g, idx) => {
                            if (idx !== currentGestureIndex && g.position && g.position.length >= 5 && g.position[0]) {
                                snapPoints.push(g.position[2]); // yMin
                                snapPoints.push(g.position[4]); // yMax
                            }
                        });
                    }
                }
                
                for (let snapPoint of snapPoints) {
                    if (Math.abs(value - snapPoint) < snapTolerance) {
                        return snapPoint;
                    }
                }
            }
            
            return value;
        }

        // Move entire gesture
        function moveGesture(x, y) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const canvas = document.getElementById('gestureCanvas');
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || !Array.isArray(preset.gestures)) return;

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture || !gesture.position || gesture.position.length < 5) return;

            let [active, xMin, yMin, xMax, yMax] = gesture.position;

            // Calculate the delta movement
            const deltaX = (x - dragStartX) / canvas.width;
            const deltaY = -(y - dragStartY) / canvas.height * 700;

            // Calculate new position
            let newXMin = dragStartGestureX + deltaX;
            let newYMin = dragStartGestureY + deltaY;

            // Calculate gesture dimensions
            const width = xMax - xMin;
            const height = yMax - yMin;

            // Apply snapping to the min corner
            newXMin = applySnapping(newXMin, true);
            newYMin = applySnapping(newYMin, false);

            // Calculate new max values
            let newXMax = newXMin + width;
            let newYMax = newYMin + height;

            // Constrain to canvas bounds
            if (newXMin < 0) {
                newXMin = 0;
                newXMax = width;
            }
            if (newXMax > 1) {
                newXMax = 1;
                newXMin = 1 - width;
            }
            if (newYMin < 0) {
                newYMin = 0;
                newYMax = height;
            }
            if (newYMax > 700) {
                newYMax = 700;
                newYMin = 700 - height;
            }

            // Update the gesture position
            gesture.position = [active, newXMin, newYMin, newXMax, newYMax];
            markDirty('preset', currentPresetName);
        }

        // Update gesture boundary during drag
        function updateGestureBoundary(x, y) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const canvas = document.getElementById('gestureCanvas');
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || !Array.isArray(preset.gestures)) return;

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture || !gesture.position || gesture.position.length < 5) return;

            let [active, xMin, yMin, xMax, yMax] = gesture.position;

            // Convert mouse position to gesture coordinates
            let newX = x / canvas.width;
            let newY = 700 - (y / canvas.height * 700);

            // Apply snapping
            newX = applySnapping(newX, true);
            newY = applySnapping(newY, false);

            // Update the appropriate edge
            if (dragEdge === 'left') {
                xMin = Math.max(0, Math.min(newX, xMax - 0.01));
            } else if (dragEdge === 'right') {
                xMax = Math.min(1, Math.max(newX, xMin + 0.01));
            } else if (dragEdge === 'top') {
                yMax = Math.min(700, Math.max(newY, yMin + 1));
            } else if (dragEdge === 'bottom') {
                yMin = Math.max(0, Math.min(newY, yMax - 1));
            }

            // Update the gesture position
            gesture.position = [active, xMin, yMin, xMax, yMax];
            markDirty('preset', currentPresetName);
        }

        // Update gesture counter display
        function updateGestureCounter() {
            const counter = document.getElementById('gestureCounter');
            if (!currentPresetName || !presetsData[currentPresetName]) {
                counter.textContent = '-/-';
                return;
            }

            const preset = presetsData[currentPresetName];
            const totalGestures = preset.gestures ? preset.gestures.length : 0;
            
            if (totalGestures === 0) {
                counter.textContent = '0/0';
            } else {
                counter.textContent = `${currentGestureIndex + 1}/${totalGestures}`;
            }
        }

        // Navigate to previous gesture
        function previousGesture() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const totalGestures = preset.gestures ? preset.gestures.length : 0;
            
            if (totalGestures === 0) return;
            
            currentGestureIndex = (currentGestureIndex - 1 + totalGestures) % totalGestures;
            updateGestureCounter();
            drawGestures(currentPresetName);
            renderMidiEvents();
            renderCvEvents();
        }

        // Navigate to next gesture
        function nextGesture() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const totalGestures = preset.gestures ? preset.gestures.length : 0;
            
            if (totalGestures === 0) return;
            
            currentGestureIndex = (currentGestureIndex + 1) % totalGestures;
            updateGestureCounter();
            drawGestures(currentPresetName);
            renderMidiEvents();
            renderCvEvents();
        }

        // MIDI note conversion
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        function midiNoteToName(noteNumber) {
            const octave = Math.floor(noteNumber / 12) - 1;
            const noteName = noteNames[noteNumber % 12];
            return `${noteName}${octave}`;
        }

        function noteNameToMidi(noteName) {
            const match = noteName.match(/^([A-G]#?)(-?\d+)$/);
            if (!match) return 60; // Default to C4
            
            const [, note, octave] = match;
            const noteIndex = noteNames.indexOf(note);
            if (noteIndex === -1) return 60;
            
            return (parseInt(octave) + 1) * 12 + noteIndex;
        }

        // Render MIDI events list
        function renderMidiEvents() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || preset.gestures.length === 0) {
                document.getElementById('midiEventsList').innerHTML = '<p style="color: #999; font-size: 13px;">No gesture selected</p>';
                return;
            }

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture.midi || !Array.isArray(gesture.midi)) {
                gesture.midi = [];
            }

            const listContainer = document.getElementById('midiEventsList');
            listContainer.innerHTML = '';

            if (gesture.midi.length === 0) {
                listContainer.innerHTML = '<p style="color: #999; font-size: 13px;">No MIDI events. Click + to add.</p>';
                return;
            }

            gesture.midi.forEach((event, index) => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'midi-event';
                
                const isNote = event.note !== undefined;
                const isCC = event.cc !== undefined;
                
                // Ensure CC events have bottom/top/singleValue defaults
                if (isCC) {
                    if (event.bottom === undefined) event.bottom = 0;
                    if (event.top === undefined) event.top = 127;
                    if (event.singleValue === undefined) event.singleValue = false;
                }
                
                let controlsHTML = '<div class="midi-event-controls">';
                
                // Type selector
                controlsHTML += `
                    <div>
                        <label>Type</label>
                        <select onchange="updateMidiEventType(${index}, this.value)">
                            <option value="note" ${isNote ? 'selected' : ''}>Note</option>
                            <option value="cc" ${isCC ? 'selected' : ''}>CC</option>
                        </select>
                    </div>
                `;
                
                // Channel selector - 16 channels for Note/CC
                const channelCount = 16;
                controlsHTML += `
                    <div>
                        <label>Channel</label>
                        <select onchange="updateMidiEvent(${index}, 'channel', parseInt(this.value))">
                            ${Array.from({length: channelCount}, (_, i) => i + 1).map(ch => 
                                `<option value="${ch}" ${event.channel === ch ? 'selected' : ''}>${ch}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
                
                // Type-specific controls
                if (isNote) {
                    controlsHTML += `
                        <div>
                            <label>Note</label>
                            <input type="text" value="${midiNoteToName(event.note)}" 
                                   onchange="updateMidiEvent(${index}, 'note', noteNameToMidi(this.value))"
                                   placeholder="C4">
                        </div>
                    `;
                } else if (isCC) {
                    const ccBottom = event.bottom !== undefined ? event.bottom : 0;
                    const ccTop = event.top !== undefined ? event.top : 127;
                    const singleValue = event.singleValue !== undefined ? event.singleValue : false;
                    controlsHTML += `
                        <div>
                            <label>CC</label>
                            <input type="number" min="0" max="127" value="${event.cc || 0}" 
                                   onchange="updateMidiEvent(${index}, 'cc', parseInt(this.value))">
                        </div>
                        <div>
                            <label>Axis</label>
                            <select onchange="updateMidiEvent(${index}, 'axis', this.value)">
                                <option value="x" ${event.axis === 'x' ? 'selected' : ''}>X</option>
                                <option value="y" ${event.axis === 'y' ? 'selected' : ''}>Y</option>
                            </select>
                        </div>
                        <div style="flex-basis: 100%; display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                            <input type="checkbox" id="singleValueCheck${index}" ${singleValue ? 'checked' : ''} 
                                   onchange="toggleSingleValue(${index}, this.checked)"
                                   style="width: auto; margin: 0;">
                            <label for="singleValueCheck${index}" style="margin: 0; font-size: 13px;">Single value</label>
                        </div>
                        <div>
                            <label>Bottom: <span id="ccBottomValue${index}">${ccBottom}</span></label>
                            <input type="range" min="0" max="127" value="${ccBottom}" 
                                   id="ccBottomSlider${index}"
                                   oninput="handleCCSliderChange(${index}, 'bottom', parseInt(this.value))"
                                   style="width: 100%;">
                        </div>
                        <div>
                            <label>Top: <span id="ccTopValue${index}">${ccTop}</span></label>
                            <input type="range" min="0" max="127" value="${ccTop}" 
                                   id="ccTopSlider${index}"
                                   oninput="handleCCSliderChange(${index}, 'top', parseInt(this.value))"
                                   style="width: 100%;">
                        </div>
                    `;
                }
                
                // Delete button
                controlsHTML += `
                    <button class="nav-button btn-delete" onclick="deleteMidiEvent(${index})" title="Delete event">‚úï</button>
                `;
                
                controlsHTML += '</div>';
                eventDiv.innerHTML = controlsHTML;
                listContainer.appendChild(eventDiv);
            });
            
        }

        // Add new MIDI event
        function addMidiEvent() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || preset.gestures.length === 0) {
                showStatus('No gesture selected', 'error');
                return;
            }

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture.midi) {
                gesture.midi = [];
            }

            // Save history
            saveHistory();

            // Add default note event
            gesture.midi.push({
                channel: 1,
                note: 60
            });

            markDirty('preset', currentPresetName);
            renderMidiEvents();
            showStatus('MIDI event added', 'success');
        }

        // Render CV events list
        function renderCvEvents() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || preset.gestures.length === 0) {
                document.getElementById('cvEventsList').innerHTML = '<p style="color: #999; font-size: 13px;">No gesture selected</p>';
                return;
            }

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture.cv || !Array.isArray(gesture.cv)) {
                gesture.cv = [];
            }

            const listContainer = document.getElementById('cvEventsList');
            listContainer.innerHTML = '';

            if (gesture.cv.length === 0) {
                listContainer.innerHTML = '<p style="color: #999; font-size: 13px;">No CV events. Click + to add.</p>';
                return;
            }

            gesture.cv.forEach((event, index) => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'midi-event';
                
                // Ensure CV events have bottom/top defaults
                if (event.bottom === undefined) event.bottom = -5.0;
                if (event.top === undefined) event.top = 5.0;
                
                const cvBottom = event.bottom !== undefined ? event.bottom : -5.0;
                const cvTop = event.top !== undefined ? event.top : 5.0;
                const singleValue = event.singleValue !== undefined ? event.singleValue : false;
                
                let controlsHTML = '<div class="midi-event-controls">';
                
                // Channel selector - 4 channels for CV
                controlsHTML += `
                    <div>
                        <label>Channel</label>
                        <select onchange="updateCvEvent(${index}, 'channel', parseInt(this.value))">
                            ${Array.from({length: 4}, (_, i) => i + 1).map(ch => 
                                `<option value="${ch}" ${event.channel === ch ? 'selected' : ''}>${ch}</option>`
                            ).join('')}
                        </select>
                    </div>
                `;
                
                // CV-specific controls
                controlsHTML += `
                    <div>
                        <label>Axis</label>
                        <select onchange="updateCvEvent(${index}, 'axis', this.value)">
                            <option value="x" ${event.axis === 'x' ? 'selected' : ''}>X</option>
                            <option value="y" ${event.axis === 'y' ? 'selected' : ''}>Y</option>
                        </select>
                    </div>
                    <div style="flex-basis: 100%; display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                        <input type="checkbox" id="cvSingleValueCheck${index}" ${singleValue ? 'checked' : ''} 
                               onchange="toggleCvSingleValue(${index}, this.checked)"
                               style="width: auto; margin: 0;">
                        <label for="cvSingleValueCheck${index}" style="margin: 0; font-size: 13px;">Single value</label>
                    </div>
                    <div>
                        <label>Bottom: <span id="cvBottomValue${index}">${cvBottom.toFixed(2)}</span> V</label>
                        <input type="range" min="-5" max="5" step="0.1" value="${cvBottom}" 
                               id="cvBottomSlider${index}"
                               oninput="handleCvSliderChange(${index}, 'bottom', parseFloat(this.value))"
                               style="width: 100%;">
                    </div>
                    <div>
                        <label>Top: <span id="cvTopValue${index}">${cvTop.toFixed(2)}</span> V</label>
                        <input type="range" min="-5" max="5" step="0.1" value="${cvTop}" 
                               id="cvTopSlider${index}"
                               oninput="handleCvSliderChange(${index}, 'top', parseFloat(this.value))"
                               style="width: 100%;">
                    </div>
                `;
                
                // Delete button
                controlsHTML += `
                    <button class="nav-button btn-delete" onclick="deleteCvEvent(${index})" title="Delete event">‚úï</button>
                `;
                
                controlsHTML += '</div>';
                eventDiv.innerHTML = controlsHTML;
                listContainer.appendChild(eventDiv);
            });
        }

        // Add new CV event
        function addCvEvent() {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            if (!preset.gestures || preset.gestures.length === 0) {
                showStatus('No gesture selected', 'error');
                return;
            }

            const gesture = preset.gestures[currentGestureIndex];
            if (!gesture.cv) {
                gesture.cv = [];
            }

            // Save history
            saveHistory();

            // Add default CV event
            gesture.cv.push({
                channel: 1,
                axis: 'y',
                bottom: -5.0,
                top: 5.0,
                singleValue: false
            });

            markDirty('preset', currentPresetName);
            renderCvEvents();
            showStatus('CV event added', 'success');
        }

        // Delete CV event
        function deleteCvEvent(index) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.cv || index < 0 || index >= gesture.cv.length) return;

            // Save history
            saveHistory();

            gesture.cv.splice(index, 1);
            markDirty('preset', currentPresetName);
            renderCvEvents();
            showStatus('CV event deleted', 'success');
        }

        // Update CV event property
        function updateCvEvent(index, property, value) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.cv || index < 0 || index >= gesture.cv.length) return;

            // Save history
            saveHistory();

            gesture.cv[index][property] = value;
            markDirty('preset', currentPresetName);
            showStatus('CV event updated', 'success');
        }

        // Handle CV slider change with single value support
        function handleCvSliderChange(index, property, value) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.cv || index < 0 || index >= gesture.cv.length) return;
            
            // Save history before making changes
            saveHistory();
            
            const event = gesture.cv[index];
            const singleValue = event.singleValue !== undefined ? event.singleValue : false;
            
            // Update the changed property
            event[property] = value;
            
            // If single value mode is enabled, sync both sliders
            if (singleValue) {
                event.bottom = value;
                event.top = value;
                
                // Update both slider UI elements
                const bottomSlider = document.getElementById(`cvBottomSlider${index}`);
                const topSlider = document.getElementById(`cvTopSlider${index}`);
                const bottomValue = document.getElementById(`cvBottomValue${index}`);
                const topValue = document.getElementById(`cvTopValue${index}`);
                
                if (bottomSlider) {
                    bottomSlider.value = value;
                }
                if (topSlider) {
                    topSlider.value = value;
                }
                if (bottomValue) {
                    bottomValue.textContent = value.toFixed(2);
                }
                if (topValue) {
                    topValue.textContent = value.toFixed(2);
                }
            } else {
                // Update the display for the changed property
                const bottomValue = document.getElementById(`cvBottomValue${index}`);
                const topValue = document.getElementById(`cvTopValue${index}`);
                
                if (property === 'bottom' && bottomValue) {
                    bottomValue.textContent = value.toFixed(2);
                }
                if (property === 'top' && topValue) {
                    topValue.textContent = value.toFixed(2);
                }
            }
            
            markDirty('preset', currentPresetName);
            showStatus('CV event updated', 'success');
        }

        // Toggle CV single value mode
        function toggleCvSingleValue(index, enabled) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.cv || index < 0 || index >= gesture.cv.length) return;
            
            // Save history
            saveHistory();
            
            const event = gesture.cv[index];
            event.singleValue = enabled;
            
            if (enabled) {
                // When enabling, set both to the current value (use bottom as reference, or top if bottom is not set)
                const currentValue = event.bottom !== undefined ? event.bottom : (event.top !== undefined ? event.top : 0.0);
                event.bottom = currentValue;
                event.top = currentValue;
                
                // Update UI
                const bottomSlider = document.getElementById(`cvBottomSlider${index}`);
                const topSlider = document.getElementById(`cvTopSlider${index}`);
                const bottomValue = document.getElementById(`cvBottomValue${index}`);
                const topValue = document.getElementById(`cvTopValue${index}`);
                
                if (bottomSlider) {
                    bottomSlider.value = currentValue;
                }
                if (topSlider) {
                    topSlider.value = currentValue;
                }
                if (bottomValue) {
                    bottomValue.textContent = currentValue.toFixed(2);
                }
                if (topValue) {
                    topValue.textContent = currentValue.toFixed(2);
                }
            }
            
            markDirty('preset', currentPresetName);
            showStatus('CV event updated', 'success');
        }

        // Delete MIDI event
        function deleteMidiEvent(index) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.midi || index < 0 || index >= gesture.midi.length) return;

            // Save history
            saveHistory();

            gesture.midi.splice(index, 1);
            markDirty('preset', currentPresetName);
            renderMidiEvents();
            showStatus('MIDI event deleted', 'success');
        }

        // Handle CC slider change with single value support
        function handleCCSliderChange(index, property, value) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.midi || index < 0 || index >= gesture.midi.length) return;
            
            // Save history before making changes
            saveHistory();
            
            const event = gesture.midi[index];
            const singleValue = event.singleValue !== undefined ? event.singleValue : false;
            
            // Update the changed property
            event[property] = value;
            
            // If single value mode is enabled, sync both sliders
            if (singleValue) {
                event.bottom = value;
                event.top = value;
                
                // Update both slider UI elements
                const bottomSlider = document.getElementById(`ccBottomSlider${index}`);
                const topSlider = document.getElementById(`ccTopSlider${index}`);
                const bottomValue = document.getElementById(`ccBottomValue${index}`);
                const topValue = document.getElementById(`ccTopValue${index}`);
                
                if (bottomSlider) {
                    bottomSlider.value = value;
                }
                if (topSlider) {
                    topSlider.value = value;
                }
                if (bottomValue) {
                    bottomValue.textContent = value;
                }
                if (topValue) {
                    topValue.textContent = value;
                }
            } else {
                // Update the display for the changed property
                const bottomValue = document.getElementById(`ccBottomValue${index}`);
                const topValue = document.getElementById(`ccTopValue${index}`);
                
                if (property === 'bottom' && bottomValue) {
                    bottomValue.textContent = value;
                }
                if (property === 'top' && topValue) {
                    topValue.textContent = value;
                }
            }
            
            markDirty('preset', currentPresetName);
            showStatus('MIDI event updated', 'success');
        }

        // Toggle single value mode for MIDI events
        function toggleSingleValue(index, enabled) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.midi || index < 0 || index >= gesture.midi.length) return;
            
            // Save history
            saveHistory();
            
            const event = gesture.midi[index];
            event.singleValue = enabled;
            
            if (enabled) {
                // When enabling, set both to the current value (use bottom as reference, or top if bottom is not set)
                const currentValue = event.bottom !== undefined ? event.bottom : (event.top !== undefined ? event.top : 64);
                event.bottom = currentValue;
                event.top = currentValue;
                
                // Update UI
                const bottomSlider = document.getElementById(`ccBottomSlider${index}`);
                const topSlider = document.getElementById(`ccTopSlider${index}`);
                const bottomValue = document.getElementById(`ccBottomValue${index}`);
                const topValue = document.getElementById(`ccTopValue${index}`);
                
                if (bottomSlider) {
                    bottomSlider.value = currentValue;
                }
                if (topSlider) {
                    topSlider.value = currentValue;
                }
                if (bottomValue) {
                    bottomValue.textContent = currentValue;
                }
                if (topValue) {
                    topValue.textContent = currentValue;
                }
            }
            
            markDirty('preset', currentPresetName);
            showStatus('MIDI event updated', 'success');
        }

        // Update MIDI event property
        function updateMidiEvent(index, property, value) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.midi || index < 0 || index >= gesture.midi.length) return;

            // Save history
            saveHistory();

            gesture.midi[index][property] = value;
            markDirty('preset', currentPresetName);
            showStatus('MIDI event updated', 'success');
        }

        // Update MIDI event type (Note <-> CC <-> CV)
        function updateMidiEventType(index, type) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const preset = presetsData[currentPresetName];
            const gesture = preset.gestures[currentGestureIndex];
            
            if (!gesture.midi || index < 0 || index >= gesture.midi.length) return;

            // Save history
            saveHistory();

            const event = gesture.midi[index];
            const channel = event.channel || 1;

            if (type === 'note') {
                gesture.midi[index] = {
                    channel: channel,
                    note: 60
                };
            } else if (type === 'cc') {
                gesture.midi[index] = {
                    channel: channel,
                    cc: 0,
                    axis: 'y',
                    bottom: 0,
                    top: 127,
                    singleValue: false
                };
            }

            markDirty('preset', currentPresetName);
            renderMidiEvents();
            showStatus('MIDI event type changed', 'success');
        }

        // Delete current gesture
        function deleteGesture() {
            if (!currentPresetName || !presetsData[currentPresetName]) {
                showStatus('Please select a preset first', 'error');
                return;
            }

            const preset = presetsData[currentPresetName];
            if (!preset.gestures || preset.gestures.length === 0) {
                showStatus('No gestures to delete', 'error');
                return;
            }

            // Save history before deleting
            saveHistory();

            // Remove the gesture
            preset.gestures.splice(currentGestureIndex, 1);

            // Adjust current gesture index
            if (currentGestureIndex >= preset.gestures.length && preset.gestures.length > 0) {
                currentGestureIndex = preset.gestures.length - 1;
            } else if (preset.gestures.length === 0) {
                currentGestureIndex = 0;
            }

            // Update display
            markDirty('preset', currentPresetName);
            updateGestureCounter();
            drawGestures(currentPresetName);
            renderMidiEvents();
            renderCvEvents();

            showStatus('Gesture deleted', 'success');
        }

        // Start creating a new gesture
        function startCreateGesture() {
            if (!currentPresetName) {
                showStatus('Please select a preset first', 'error');
                return;
            }

            isCreatingGesture = true;
            newGestureStart = null;
            
            // Switch UI to creation mode
            document.getElementById('gestureNavContainer').style.display = 'none';
            document.getElementById('gestureCreateContainer').style.display = 'flex';
            
            // Change cursor
            const canvas = document.getElementById('gestureCanvas');
            canvas.style.cursor = 'crosshair';
            
            // Redraw to show all gestures dimmed
            drawGestures(currentPresetName);
            
            showStatus('Draw a rectangle on the canvas to create a new gesture', 'success');
        }

        // Cancel gesture creation
        function cancelCreateGesture() {
            isCreatingGesture = false;
            newGestureStart = null;
            
            // Switch UI back to navigation mode
            document.getElementById('gestureNavContainer').style.display = 'flex';
            document.getElementById('gestureCreateContainer').style.display = 'none';
            
            // Reset cursor
            const canvas = document.getElementById('gestureCanvas');
            canvas.style.cursor = 'default';
            
            // Redraw
            drawGestures(currentPresetName);
            
            showStatus('Gesture creation cancelled', 'success');
        }

        // Complete gesture creation
        function completeCreateGesture(x1, y1, x2, y2) {
            if (!currentPresetName || !presetsData[currentPresetName]) return;
            
            const canvas = document.getElementById('gestureCanvas');
            
            // Convert to gesture coordinates
            const xMin = Math.min(x1, x2) / canvas.width;
            const xMax = Math.max(x1, x2) / canvas.width;
            const yMin = Math.min(700 - y2 / canvas.height * 700, 700 - y1 / canvas.height * 700);
            const yMax = Math.max(700 - y2 / canvas.height * 700, 700 - y1 / canvas.height * 700);
            
            // Ensure minimum size
            if (xMax - xMin < 0.01 || yMax - yMin < 1) {
                showStatus('Gesture too small, please draw a larger area', 'error');
                return;
            }
            
            // Save history before creating
            saveHistory();
            
            // Create new gesture with default MIDI settings
            const newGesture = {
                midi: [
                    {
                        channel: 1,
                        note: 60
                    }
                ],
                cv: [],
                position: [true, xMin, yMin, xMax, yMax]
            };
            
            // Add to preset
            const preset = presetsData[currentPresetName];
            if (!preset.gestures) {
                preset.gestures = [];
            }
            preset.gestures.push(newGesture);
            
            // Select the new gesture
            currentGestureIndex = preset.gestures.length - 1;
            
            // Exit creation mode
            isCreatingGesture = false;
            newGestureStart = null;
            
            // Switch UI back
            document.getElementById('gestureNavContainer').style.display = 'flex';
            document.getElementById('gestureCreateContainer').style.display = 'none';
            
            // Reset cursor
            canvas.style.cursor = 'default';
            
            // Update display
            markDirty('preset', currentPresetName);
            updateGestureCounter();
            drawGestures(currentPresetName);
            renderMidiEvents();
            renderCvEvents();
            
            showStatus(`New gesture created (${currentGestureIndex + 1}/${preset.gestures.length})`, 'success');
        }

        // Rename current preset
        function renamePreset() {
            if (!currentPresetName) {
                showStatus('Please select a preset to rename', 'error');
                return;
            }

            const newName = prompt(`Rename preset "${currentPresetName}" to:`, currentPresetName);
            
            if (!newName) return; // User cancelled
            
            // Validate new name
            if (newName === currentPresetName) return; // Same name, no change
            
            if (!/^[a-zA-Z0-9_-]+$/.test(newName)) {
                showStatus('Preset name can only contain letters, numbers, hyphens, and underscores', 'error');
                return;
            }
            
            if (presetsData[newName]) {
                showStatus(`Preset "${newName}" already exists`, 'error');
                return;
            }

            const oldName = currentPresetName;

            // Rename the preset
            presetsData[newName] = presetsData[oldName];
            delete presetsData[oldName];
            
            // Update presetNames array
            const index = presetNames.indexOf(oldName);
            if (index !== -1) {
                presetNames[index] = newName;
            }
            
            // Update config if this was the default preset
            if (configData.preset === oldName) {
                configData.preset = newName;
            }
            
            // Update current preset name
            currentPresetName = newName;
            
            // Rebuild preset selectors
            populatePresetSelectors();
            
            // Restore selections
            document.getElementById('selectedPreset').value = newName;
            document.getElementById('defaultPreset').value = configData.preset || '';
            
            showStatus(`Preset renamed from "${oldName}" to "${newName}"`, 'success');
        }

        // Copy current preset
        function copyPreset() {
            if (!currentPresetName) {
                showStatus('Please select a preset to copy', 'error');
                return;
            }

            const newName = prompt(`Copy preset "${currentPresetName}" as:`, currentPresetName + '_copy');
            
            if (!newName) return; // User cancelled
            
            // Validate new name
            if (!/^[a-zA-Z0-9_-]+$/.test(newName)) {
                showStatus('Preset name can only contain letters, numbers, hyphens, and underscores', 'error');
                return;
            }
            
            if (presetsData[newName]) {
                showStatus(`Preset "${newName}" already exists`, 'error');
                return;
            }

            // Create a deep copy of the preset
            presetsData[newName] = JSON.parse(JSON.stringify(presetsData[currentPresetName]));
            
            // Add to presetNames array
            presetNames.push(newName);
            
            // Rebuild preset selectors
            populatePresetSelectors();
            
            // Switch to the new copy
            currentPresetName = newName;
            currentGestureIndex = 0;
            document.getElementById('selectedPreset').value = newName;
            updateGestureCounter();
            drawGestures(newName);
            
            showStatus(`Preset copied as "${newName}"`, 'success');
        }

        // Delete current preset
        function deletePreset() {
            if (!currentPresetName) {
                showStatus('Please select a preset to delete', 'error');
                return;
            }

            const confirmed = confirm(`Are you sure you want to DELETE preset "${currentPresetName}"?\n\nThis will permanently remove the preset and cannot be undone.`);
            
            if (!confirmed) return;

            const deletedName = currentPresetName;

            // Delete the preset
            delete presetsData[deletedName];
            
            // Remove from presetNames array
            const index = presetNames.indexOf(deletedName);
            if (index !== -1) {
                presetNames.splice(index, 1);
            }
            
            // Clear config if this was the default preset
            if (configData.preset === deletedName) {
                configData.preset = '';
            }
            
            // Switch to first available preset or clear
            if (presetNames.length > 0) {
                currentPresetName = presetNames[0];
                currentGestureIndex = 0;
            } else {
                currentPresetName = '';
                currentGestureIndex = 0;
            }
            
            // Clear history
            undoStack = [];
            redoStack = [];
            
            // Rebuild preset selectors
            populatePresetSelectors();
            
            // Restore selections
            document.getElementById('selectedPreset').value = currentPresetName || '';
            document.getElementById('defaultPreset').value = configData.preset || '';
            
            updateGestureCounter();
            updateHistoryButtons();
            drawGestures(currentPresetName);
            
            showStatus(`Preset "${deletedName}" deleted`, 'success');
        }

        // Clear current preset
        function clearPreset() {
            if (!currentPresetName) {
                showStatus('Please select a preset to clear', 'error');
                return;
            }

            const confirmed = confirm(`Are you sure you want to clear all gestures from preset "${currentPresetName}"?`);
            
            if (!confirmed) return;

            // Save state before clearing
            saveHistory();

            // Clear all gestures
            presetsData[currentPresetName] = { gestures: [] };
            
            // Reset gesture index
            currentGestureIndex = 0;
            updateGestureCounter();
            drawGestures(currentPresetName);
            
            showStatus(`Preset "${currentPresetName}" cleared`, 'success');
        }

        // Create new preset
        function createNewPreset() {
            const newName = prompt('Enter name for the new preset:', 'new_preset');
            
            if (!newName) return; // User cancelled
            
            // Validate new name
            if (!/^[a-zA-Z0-9_-]+$/.test(newName)) {
                showStatus('Preset name can only contain letters, numbers, hyphens, and underscores', 'error');
                return;
            }
            
            if (presetsData[newName]) {
                showStatus(`Preset "${newName}" already exists`, 'error');
                return;
            }

            // Create new empty preset
            presetsData[newName] = { gestures: [] };
            
            // Add to presetNames array
            presetNames.push(newName);
            
            // Rebuild preset selectors
            populatePresetSelectors();
            
            // Switch to the new preset
            currentPresetName = newName;
            currentGestureIndex = 0;
            document.getElementById('selectedPreset').value = newName;
            updateGestureCounter();
            drawGestures(newName);
            
            showStatus(`New preset "${newName}" created`, 'success');
        }

        // Save all changes
        function saveAll() {
            try {
                // Update calibData from inputs
                for (let i = 0; i < 7; i++) {
                    const minSignalInput = document.getElementById(`calibMinSignal${i}`);
                    const maxDistanceInput = document.getElementById(`calibMaxDistance${i}`);
                    if (minSignalInput) {
                        calibData.min_signal[i] = parseInt(minSignalInput.value) || 0;
                    }
                    if (maxDistanceInput) {
                        calibData.max_distance[i] = parseInt(maxDistanceInput.value) || 1000;
                    }
                }

                // Update configData from inputs
                configData.preset = document.getElementById('defaultPreset').value;
                configData.color1 = document.getElementById('color1').value;
                configData.color2 = document.getElementById('color2').value;
                configData.wifi_ssid = document.getElementById('wifiSsid').value;
                configData.wifi_password = document.getElementById('wifiPassword').value;
                configData.wifi_ap_ssid = document.getElementById('wifiApSsid').value;
                configData.wifi_ap_password = document.getElementById('wifiApPassword').value;
                configData.distance_min_avg_speed = parseInt(document.getElementById('distanceMinAvgSpeed').value) || 2;
                configData.distance_max_avg_speed = parseInt(document.getElementById('distanceMaxAvgSpeed').value) || 8;
                configData.distance_avg_reset_threshold = parseInt(document.getElementById('distanceAvgResetThreshold').value) || 100;
                configData.x_avg_speed = parseInt(document.getElementById('xAvgSpeed').value) || 50;
                configData.valid_streak_threshold = parseInt(document.getElementById('validStreakThreshold').value) || 5;

                showStatus('Changes saved in memory. Use "Download All Files" to export.', 'success');
            } catch (error) {
                showStatus('Error saving changes: ' + error.message, 'error');
            }
        }

        // Download all files
        async function downloadAll() {
            try {
                const zip = new JSZip();
                
                // Add calib.yml
                const calibYaml = jsyaml.dump(calibData, { lineWidth: -1 });
                zip.file('calib.yml', calibYaml);

                // Add config.yml
                const configYaml = jsyaml.dump(configData, { lineWidth: -1 });
                zip.file('config.yml', configYaml);

                // Add presets folder
                const presetsFolder = zip.folder('presets');
                for (const [name, data] of Object.entries(presetsData)) {
                    const presetYaml = jsyaml.dump(data, { lineWidth: -1 });
                    presetsFolder.file(`${name}.yml`, presetYaml);
                }

                // Generate and download ZIP
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'data.zip';
                a.click();
                URL.revokeObjectURL(url);

                showStatus('data.zip downloaded successfully', 'success');
            } catch (error) {
                showStatus('Error creating archive: ' + error.message, 'error');
            }
        }

        // Download a file
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Show status message
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }

        // Create reverb impulse response
        function createReverbImpulse(duration = 2, decay = 2) {
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);
            
            for (let i = 0; i < length; i++) {
                const n = length - i;
                impulseL[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
                impulseR[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
            }
            
            return impulse;
        }

        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create global filter (lowpass)
                globalFilter = audioContext.createBiquadFilter();
                globalFilter.type = 'lowpass';
                globalFilter.frequency.value = 5000; // Default cutoff
                globalFilter.Q.value = 1; // Default resonance
                
                // Create reverb
                reverbNode = audioContext.createConvolver();
                reverbNode.buffer = createReverbImpulse(2, 2);
                
                // Create dry/wet gains
                dryGain = audioContext.createGain();
                dryGain.gain.value = 1.0; // Full dry signal
                
                wetGain = audioContext.createGain();
                wetGain.gain.value = 0.0; // No reverb by default
                
                // Create master gain
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3; // Master volume
                
                // Connect the chain: filter -> dry + wet -> master -> destination
                globalFilter.connect(dryGain);
                globalFilter.connect(reverbNode);
                reverbNode.connect(wetGain);
                
                dryGain.connect(masterGain);
                wetGain.connect(masterGain);
                masterGain.connect(audioContext.destination);
            }
            
            // Resume context if suspended (needed for user interaction requirement)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Convert MIDI note number to frequency
        function midiNoteToFrequency(note) {
            return 440 * Math.pow(2, (note - 69) / 12);
        }

        // Process CC events
        function processCCEvents(activeGestures) {
            if (!audioContext || !globalFilter) return;

            // Collect all CC events from active gestures
            const ccValues = {
                1: null, // Filter cutoff
                2: null, // Resonance
                3: null  // Reverb
            };

            activeGestures.forEach(({ gesture, gestureX, gestureY }) => {
                if (gesture.midi && Array.isArray(gesture.midi)) {
                    gesture.midi.forEach(event => {
                        if (event.cc !== undefined && ccValues.hasOwnProperty(event.cc)) {
                            // Calculate CC value based on axis and position within gesture
                            const [active, xMin, yMin, xMax, yMax] = gesture.position;
                            const ccBottom = event.bottom !== undefined ? event.bottom : 0;
                            const ccTop = event.top !== undefined ? event.top : 127;
                            let normalizedValue = 0;
                            
                            if (event.axis === 'x') {
                                const normalizedX = (gestureX - xMin) / (xMax - xMin);
                                normalizedValue = Math.max(0, Math.min(1, normalizedX));
                            } else {
                                const normalizedY = (gestureY - yMin) / (yMax - yMin);
                                normalizedValue = Math.max(0, Math.min(1, normalizedY));
                            }
                            
                            // Map normalized value (0-1) to CC range (bottom-top)
                            const ccValue = Math.round(ccBottom + normalizedValue * (ccTop - ccBottom));
                            
                            // Use the highest value if multiple gestures control the same CC
                            if (ccValues[event.cc] === null || ccValue > ccValues[event.cc]) {
                                ccValues[event.cc] = ccValue;
                            }
                        }
                    });
                }
            });

            const now = audioContext.currentTime;
            const smoothTime = 0.05; // 50ms smooth transition

            // CC1: Filter cutoff (20Hz - 20kHz)
            if (ccValues[1] !== null) {
                const normalizedValue = ccValues[1] / 127;
                // Exponential scale for better perceptual response
                const minFreq = 20;
                const maxFreq = 20000;
                const cutoffFreq = minFreq * Math.pow(maxFreq / minFreq, normalizedValue);
                globalFilter.frequency.setTargetAtTime(cutoffFreq, now, smoothTime);
            }

            // CC2: Resonance/Q (0.1 - 30)
            if (ccValues[2] !== null) {
                const normalizedValue = ccValues[2] / 127;
                // Exponential scale for resonance
                const minQ = 0.1;
                const maxQ = 30;
                const qValue = minQ * Math.pow(maxQ / minQ, normalizedValue);
                globalFilter.Q.setTargetAtTime(qValue, now, smoothTime);
            }

            // CC3: Reverb wet/dry mix (0.0 - 1.0)
            if (ccValues[3] !== null) {
                const normalizedValue = ccValues[3] / 127;
                wetGain.gain.setTargetAtTime(normalizedValue * 0.5, now, smoothTime); // Max 50% wet
                dryGain.gain.setTargetAtTime(1.0 - normalizedValue * 0.3, now, smoothTime); // Reduce dry slightly
            }

            // Reset to defaults if no CC events
            if (ccValues[1] === null) {
                globalFilter.frequency.setTargetAtTime(5000, now, smoothTime);
            }
            if (ccValues[2] === null) {
                globalFilter.Q.setTargetAtTime(1, now, smoothTime);
            }
            if (ccValues[3] === null) {
                wetGain.gain.setTargetAtTime(0, now, smoothTime);
                dryGain.gain.setTargetAtTime(1.0, now, smoothTime);
            }
        }

        // Start playing a note
        function playNote(noteNumber, velocity = 127) {
            if (!audioContext) return;
            
            const noteKey = `note_${noteNumber}`;
            
            // Don't play if already playing
            if (activeNotes.has(noteKey)) return;
            
            const frequency = midiNoteToFrequency(noteNumber);
            const now = audioContext.currentTime;
            
            // Create main oscillator (triangle wave for softer sound)
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'triangle';
            oscillator.frequency.value = frequency;
            
            // Create a second oscillator for richer sound (perfect fifth)
            const oscillator2 = audioContext.createOscillator();
            oscillator2.type = 'sine';
            oscillator2.frequency.value = frequency * 1.5; // Perfect fifth
            
            // Create gain nodes
            const gainNode = audioContext.createGain();
            const gainNode2 = audioContext.createGain();
            
            // Main oscillator louder, second one quieter for depth
            const volume = (velocity / 127) * 0.25;
            gainNode.gain.value = 0;
            gainNode2.gain.value = 0;
            
            // ADSR envelope - Attack
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.05); // 50ms attack
            gainNode2.gain.setValueAtTime(0, now);
            gainNode2.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
            
            // Connect nodes - route through global filter
            oscillator.connect(gainNode);
            oscillator2.connect(gainNode2);
            gainNode.connect(globalFilter);
            gainNode2.connect(globalFilter);
            
            // Start oscillators
            oscillator.start();
            oscillator2.start();
            
            // Store reference
            activeNotes.set(noteKey, { oscillator, oscillator2, gainNode, gainNode2 });
        }

        // Stop playing a note
        function stopNote(noteNumber) {
            const noteKey = `note_${noteNumber}`;
            
            if (activeNotes.has(noteKey)) {
                const { oscillator, oscillator2, gainNode, gainNode2 } = activeNotes.get(noteKey);
                
                // Fade out to avoid clicks (Release phase of ADSR)
                const now = audioContext.currentTime;
                const releaseTime = 0.1; // 100ms release
                
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);
                
                gainNode2.gain.setValueAtTime(gainNode2.gain.value, now);
                gainNode2.gain.linearRampToValueAtTime(0, now + releaseTime);
                
                // Stop after fade out
                oscillator.stop(now + releaseTime);
                oscillator2.stop(now + releaseTime);
                
                activeNotes.delete(noteKey);
            }
        }

        // Stop all notes
        function stopAllNotes() {
            for (const [noteKey, noteData] of activeNotes.entries()) {
                try {
                    const now = audioContext.currentTime;
                    const releaseTime = 0.1;
                    
                    if (noteData.gainNode) {
                        noteData.gainNode.gain.setValueAtTime(noteData.gainNode.gain.value, now);
                        noteData.gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);
                    }
                    
                    if (noteData.gainNode2) {
                        noteData.gainNode2.gain.setValueAtTime(noteData.gainNode2.gain.value, now);
                        noteData.gainNode2.gain.linearRampToValueAtTime(0, now + releaseTime);
                    }
                    
                    if (noteData.oscillator) {
                        noteData.oscillator.stop(now + releaseTime);
                    }
                    
                    if (noteData.oscillator2) {
                        noteData.oscillator2.stop(now + releaseTime);
                    }
                } catch (e) {
                    // Ignore errors if already stopped
                }
            }
            activeNotes.clear();
        }

        // Enter play mode
        function enterPlayMode() {
            if (!currentPresetName || !presetsData[currentPresetName]) {
                showStatus('Please select a preset first', 'error');
                return;
            }

            // Initialize audio
            initAudio();

            isPlayMode = true;
            const overlay = document.getElementById('playModeOverlay');
            overlay.style.display = 'block';

            playModeCanvas = document.getElementById('playModeCanvas');
            playModeCtx = playModeCanvas.getContext('2d');

            // Set canvas size to window size
            resizePlayModeCanvas();

            // Setup event listeners
            playModeCanvas.addEventListener('mousemove', handlePlayModeMouseMove);
            window.addEventListener('resize', resizePlayModeCanvas);
            document.addEventListener('keydown', handlePlayModeKeydown);

            // Initial draw
            drawPlayMode();
            updatePlayModeInfo();
            
            // Initialize audio parameters to defaults
            processCCEvents([]);
        }

        // Exit play mode
        function exitPlayMode() {
            isPlayMode = false;
            const overlay = document.getElementById('playModeOverlay');
            overlay.style.display = 'none';

            if (playModeCanvas) {
                playModeCanvas.removeEventListener('mousemove', handlePlayModeMouseMove);
            }
            window.removeEventListener('resize', resizePlayModeCanvas);
            document.removeEventListener('keydown', handlePlayModeKeydown);

            // Stop all playing notes
            stopAllNotes();
            
            // Reset audio parameters to defaults
            if (audioContext && globalFilter) {
                const now = audioContext.currentTime;
                globalFilter.frequency.setTargetAtTime(5000, now, 0.1);
                globalFilter.Q.setTargetAtTime(1, now, 0.1);
                if (wetGain && dryGain) {
                    wetGain.gain.setTargetAtTime(0, now, 0.1);
                    dryGain.gain.setTargetAtTime(1.0, now, 0.1);
                }
            }

            activePlayGestures = [];
            playModeSignalPoints = [];
        }

        // Handle keydown in play mode
        function handlePlayModeKeydown(e) {
            if (e.key === 'Escape' && isPlayMode) {
                exitPlayMode();
            }
        }

        // Resize play mode canvas
        function resizePlayModeCanvas() {
            if (!playModeCanvas) return;
            
            playModeCanvas.width = window.innerWidth;
            playModeCanvas.height = window.innerHeight;
            
            if (isPlayMode) {
                drawPlayMode();
            }
        }

        // Handle mouse move in play mode
        function handlePlayModeMouseMove(event) {
            if (!isPlayMode || !currentPresetName || !presetsData[currentPresetName]) return;

            // When serial is connected, signal points drive play mode ‚Äî ignore mouse
            if (serialConnected) return;

            const rect = playModeCanvas.getBoundingClientRect();
            const scaleX = playModeCanvas.width / rect.width;
            const scaleY = playModeCanvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            // Convert to gesture coordinates
            const gestureX = x / playModeCanvas.width;
            const gestureY = 700 - (y / playModeCanvas.height * 700);

            // Store mouse coordinates
            playModeMouseX = gestureX;
            playModeMouseY = gestureY;

            // Find active gestures
            const preset = presetsData[currentPresetName];
            const previousActiveGestures = activePlayGestures;
            activePlayGestures = [];

            if (preset.gestures && Array.isArray(preset.gestures)) {
                preset.gestures.forEach((gesture, index) => {
                    if (gesture.position && Array.isArray(gesture.position) && gesture.position.length >= 5) {
                        const [active, xMin, yMin, xMax, yMax] = gesture.position;
                        
                        if (active && gestureX >= xMin && gestureX <= xMax && gestureY >= yMin && gestureY <= yMax) {
                            activePlayGestures.push({ gesture, index, gestureX, gestureY });
                        }
                    }
                });
            }

            // Update audio playback based on active gestures
            updateAudioPlayback(previousActiveGestures, activePlayGestures);
            
            // Process CC events from active gestures
            processCCEvents(activePlayGestures);

            drawPlayMode();
            updatePlayModeInfo();
        }

        // Update play mode with signal processor points (from sensor data)
        function updatePlayModeWithSignalPoints(points) {
            if (!isPlayMode || !currentPresetName || !presetsData[currentPresetName]) return;

            playModeSignalPoints = points;

            const preset = presetsData[currentPresetName];
            const previousActiveGestures = activePlayGestures;
            activePlayGestures = [];

            if (preset.gestures && Array.isArray(preset.gestures)) {
                for (const pt of points) {
                    const gx = pt.x;    // 0-1
                    const gy = pt.dist; // distance mm (for gesture bounds matching)

                    preset.gestures.forEach((gesture, index) => {
                        if (gesture.position && Array.isArray(gesture.position) && gesture.position.length >= 5) {
                            const [active, xMin, yMin, xMax, yMax] = gesture.position;
                            if (active && gx >= xMin && gx <= xMax && gy >= yMin && gy <= yMax) {
                                // Avoid duplicates (two points hitting the same gesture)
                                if (!activePlayGestures.some(ag => ag.index === index)) {
                                    activePlayGestures.push({ gesture, index, gestureX: gx, gestureY: gy });
                                }
                            }
                        }
                    });
                }
            }

            updateAudioPlayback(previousActiveGestures, activePlayGestures);
            processCCEvents(activePlayGestures);
            drawPlayMode();
            updatePlayModeInfo();
        }

        // Update audio playback based on gesture changes
        function updateAudioPlayback(previousGestures, currentGestures) {
            if (!audioContext) return;

            // Get sets of notes that should be playing
            const previousNotes = new Set();
            const currentNotes = new Set();

            // Collect notes from previous gestures
            previousGestures.forEach(({ gesture }) => {
                if (gesture.midi && Array.isArray(gesture.midi)) {
                    gesture.midi.forEach(event => {
                        if (event.note !== undefined) {
                            previousNotes.add(event.note);
                        }
                    });
                }
            });

            // Collect notes from current gestures
            currentGestures.forEach(({ gesture }) => {
                if (gesture.midi && Array.isArray(gesture.midi)) {
                    gesture.midi.forEach(event => {
                        if (event.note !== undefined) {
                            currentNotes.add(event.note);
                        }
                    });
                }
            });

            // Stop notes that are no longer active
            for (const note of previousNotes) {
                if (!currentNotes.has(note)) {
                    stopNote(note);
                }
            }

            // Start notes that became active
            for (const note of currentNotes) {
                if (!previousNotes.has(note)) {
                    playNote(note);
                }
            }
        }

        // Draw play mode canvas
        function drawPlayMode() {
            if (!playModeCtx || !currentPresetName || !presetsData[currentPresetName]) return;

            const canvas = playModeCanvas;
            const ctx = playModeCtx;
            const preset = presetsData[currentPresetName];

            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let i = 0; i <= 7; i++) {
                const x = (canvas.width / 7) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= 7; i++) {
                const y = canvas.height - (canvas.height / 700) * i * 100;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw axis labels
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '14px sans-serif';
            
            // Y axis labels
            for (let i = 0; i <= 7; i++) {
                const y = canvas.height - (canvas.height / 700) * i * 100;
                ctx.fillText(`${i * 100}`, 10, y - 5);
            }

            // Draw gestures
            if (preset.gestures && Array.isArray(preset.gestures)) {
                preset.gestures.forEach((gesture, index) => {
                    if (gesture.position && Array.isArray(gesture.position) && gesture.position.length >= 5) {
                        const [active, xMin, yMin, xMax, yMax] = gesture.position;
                        
                        if (!active) return;

                        // Convert coordinates
                        const x1 = xMin * canvas.width;
                        const x2 = xMax * canvas.width;
                        const y1 = canvas.height - (yMax / 700 * canvas.height);
                        const y2 = canvas.height - (yMin / 700 * canvas.height);

                        const width = x2 - x1;
                        const height = y2 - y1;

                        const isActive = activePlayGestures.some(ag => ag.index === index);
                        const hue = index * 360 / preset.gestures.length;

                        // Draw rectangle
                        if (isActive) {
                            ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                            ctx.fillRect(x1, y1, width, height);
                            ctx.strokeStyle = `hsla(${hue}, 70%, 40%, 1)`;
                            ctx.lineWidth = 4;
                        } else {
                            ctx.fillStyle = `hsla(${hue}, 50%, 50%, 0.3)`;
                            ctx.fillRect(x1, y1, width, height);
                            ctx.strokeStyle = `hsla(${hue}, 50%, 40%, 0.6)`;
                            ctx.lineWidth = 2;
                        }
                        ctx.strokeRect(x1, y1, width, height);

                        // Draw label
                        ctx.fillStyle = isActive ? '#fff' : '#aaa';
                        ctx.font = isActive ? 'bold 24px sans-serif' : 'bold 18px sans-serif';
                        ctx.fillText(`G${index + 1}`, x1 + 10, y1 + 30);
                    }
                });
            }

            // Draw signal points (from sensor data) ‚Äî filtered, green
            for (const pt of playModeSignalPoints) {
                const cx = pt.x * canvas.width;
                const cy = Math.max(0, canvas.height * (1 - pt.y));

                // Outer glow
                ctx.beginPath();
                ctx.arc(cx, cy, 20, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(68, 255, 68, 0.3)';
                ctx.fill();

                // Inner dot
                ctx.beginPath();
                ctx.arc(cx, cy, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#44ff44';
                ctx.fill();

                // White center
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }
        }

        // Update play mode info panel
        function updatePlayModeInfo() {
            const container = document.getElementById('playModeGestures');
            
            if (activePlayGestures.length === 0) {
                const hint = serialConnected
                    ? 'Move hand over sensors to trigger gestures'
                    : 'Move mouse over gestures to see MIDI events';
                container.innerHTML = '<div style="color: #999;">' + hint + '</div>';
                return;
            }

            let html = '';
            let hasActiveNotes = false;
            
            activePlayGestures.forEach(({ gesture, index, gestureX, gestureY }) => {
                html += '<div class="play-mode-gesture-item">';
                html += `<div class="play-mode-gesture-title">Gesture ${index + 1}</div>`;
                
                if (gesture.midi && Array.isArray(gesture.midi)) {
                    gesture.midi.forEach((event) => {
                        html += '<div class="play-mode-midi-event">';
                        
                        if (event.note !== undefined) {
                            hasActiveNotes = true;
                            html += `‚ô™ CH${event.channel} Note: ${midiNoteToName(event.note)} (${event.note}) <span class="audio-indicator">üîä</span>`;
                        } else if (event.cc !== undefined) {
                            // Calculate CC value based on axis and position within gesture
                            const [active, xMin, yMin, xMax, yMax] = gesture.position;
                            const ccBottom = event.bottom !== undefined ? event.bottom : 0;
                            const ccTop = event.top !== undefined ? event.top : 127;
                            let normalizedValue = 0;
                            
                            if (event.axis === 'x') {
                                // Normalize X position within gesture bounds (0-1)
                                const normalizedX = (gestureX - xMin) / (xMax - xMin);
                                normalizedValue = Math.max(0, Math.min(1, normalizedX));
                            } else {
                                // Normalize Y position within gesture bounds (0-1)
                                const normalizedY = (gestureY - yMin) / (yMax - yMin);
                                normalizedValue = Math.max(0, Math.min(1, normalizedY));
                            }
                            
                            // Map normalized value (0-1) to CC range (bottom-top)
                            const ccValue = Math.round(ccBottom + normalizedValue * (ccTop - ccBottom));
                            
                            // Add description for special CC numbers
                            let ccDescription = '';
                            let ccIcon = '‚öô';
                            if (event.cc === 1) {
                                ccDescription = ' (Filter Cutoff)';
                                ccIcon = 'üéõ';
                            } else if (event.cc === 2) {
                                ccDescription = ' (Resonance)';
                                ccIcon = 'üîä';
                            } else if (event.cc === 3) {
                                ccDescription = ' (Reverb)';
                                ccIcon = '‚ú®';
                            }
                            
                            html += `${ccIcon} CH${event.channel} CC${event.cc}${ccDescription} (${event.axis?.toUpperCase() || 'Y'} axis): <strong>${ccValue}</strong>`;
                            
                            // Add active indicator for special CCs
                            if (event.cc >= 1 && event.cc <= 3) {
                                html += '<span class="audio-indicator">‚óè</span>';
                            }
                        }
                        
                        html += '</div>';
                    });
                } else {
                    html += '<div class="play-mode-midi-event" style="color: #999;">No MIDI events</div>';
                }
                
                // Display CV events
                if (gesture.cv && Array.isArray(gesture.cv)) {
                    gesture.cv.forEach((event) => {
                        html += '<div class="play-mode-midi-event">';
                        
                        // Calculate CV value based on axis and position within gesture
                        const [active, xMin, yMin, xMax, yMax] = gesture.position;
                        const cvBottom = event.bottom !== undefined ? event.bottom : 0;
                        const cvTop = event.top !== undefined ? event.top : 127;
                        let normalizedValue = 0;
                        
                        if (event.axis === 'x') {
                            // Normalize X position within gesture bounds (0-1)
                            const normalizedX = (gestureX - xMin) / (xMax - xMin);
                            normalizedValue = Math.max(0, Math.min(1, normalizedX));
                        } else {
                            // Normalize Y position within gesture bounds (0-1)
                            const normalizedY = (gestureY - yMin) / (yMax - yMin);
                            normalizedValue = Math.max(0, Math.min(1, normalizedY));
                        }
                        
                        // Map normalized value (0-1) to CV range (bottom-top)
                        const cvValue = Math.round(cvBottom + normalizedValue * (cvTop - cvBottom));
                        
                        html += `‚ö° CH${event.channel} CV (${event.axis?.toUpperCase() || 'Y'} axis): <strong>${cvValue}</strong>`;
                        
                        html += '</div>';
                    });
                }
                
                html += '</div>';
            });
            
            container.innerHTML = html;
        }
    </script>
</body>
</html>

