<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Settings Loader</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        
        input, select, button {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background-color: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }
        
        button:hover {
            background-color: #005a9e;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        #generateBtn:hover {
            background-color: #218838;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .status.info {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
            color: #1976d2;
        }
        
        .status.success {
            background-color: #e8f5e8;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }
        
        .status.error {
            background-color: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
        }
        
        .log {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 15px;
            background-color: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .settings-preview {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        .settings-preview summary {
            cursor: pointer;
            padding: 10px;
            margin: -15px -15px 15px -15px;
            background-color: #e9ecef;
            border-radius: 4px 4px 0 0;
            font-weight: 600;
            user-select: none;
        }
        
        .settings-preview summary:hover {
            background-color: #dee2e6;
        }
        
        .settings-preview[open] summary {
            border-bottom: 1px solid #dee2e6;
            border-radius: 4px 4px 0 0;
        }
        
        .flex-row {
            display: flex;
            gap: 20px;
        }
        
        .flex-row > * {
            flex: 1;
        }
        
        @media (max-width: 768px) {
            .flex-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Device Settings Loader</h1>
        <p>Upload YAML configuration and send to device via serial connection</p>
        
        <div class="form-group">
            <label>üìÑ Configuration Files:</label>
            <div style="display: flex; gap: 10px; margin-top: 5px;">
                <a href="device.yaml" download style="padding: 8px 16px; background-color: #007acc; color: white; text-decoration: none; border-radius: 4px; font-size: 14px;">üìã device.yaml</a>
                <a href="quray.txt" download style="padding: 8px 16px; background-color: #007acc; color: white; text-decoration: none; border-radius: 4px; font-size: 14px;">üìÑ quray.txt</a>
            </div>
        </div>
        
        <div class="form-group">
            <label>ü§ñ AI Configuration Generator:</label>
            <div style="margin-top: 10px;">
                <div style="margin-bottom: 10px;">
                    <label for="openaiKey" style="font-size: 14px;">OpenAI API Key:</label>
                    <input type="password" id="openaiKey" placeholder="sk-..." style="margin-bottom: 5px;">
                    <small style="color: #666; display: block;">‚ö†Ô∏è Warning: API key will be visible in browser. Use only for testing!</small>
                </div>
                <div style="margin-bottom: 10px;">
                    <label for="aiPrompt" style="font-size: 14px;">Describe your MIDI controller setup:</label>
                    <textarea id="aiPrompt" rows="3" placeholder="e.g., Create a configuration for a DJ controller with 4 zones: drums, bass, melody, and effects..." style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                </div>
                <button type="button" id="generateBtn" style="background-color: #28a745;">üöÄ Generate YAML with AI</button>
            </div>
        </div>
        
        <form id="deviceForm">
            <div class="flex-row">
                <div class="form-group">
                    <label for="baudRate">Baud Rate:</label>
                    <select id="baudRate">
                        <option value="9600">9600</option>
                        <option value="115200">115200</option>
                        <option value="921600" selected>921600</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="timeout">Timeout (seconds):</label>
                    <input type="number" id="timeout" value="5" min="1" max="30">
                </div>
            </div>
            
            <div class="form-group">
                <label for="configFile">Select YAML Config File:</label>
                <input type="file" id="configFile" accept=".yaml,.yml" required>
            </div>
            
            <button type="button" id="connectBtn">Connect to Device</button>
            <button type="button" id="uploadBtn" disabled>Upload Settings</button>
            <button type="button" id="disconnectBtn" disabled>Disconnect</button>
        </form>
        
        <details id="settingsPreview" class="settings-preview" style="display: none;">
            <summary>üìã Settings Preview</summary>
            <pre id="settingsContent"></pre>
        </details>
        
        <div id="status" class="status info" style="display: none;"></div>
        <div id="log" class="log"></div>
    </div>

    <script>
        // Global variables
        let port = null;
        let reader = null;
        let writer = null;
        let currentSettings = null;
        let isConnected = false;
        
        // UI Elements
        const connectBtn = document.getElementById('connectBtn');
        const uploadBtn = document.getElementById('uploadBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const configFile = document.getElementById('configFile');
        const settingsPreview = document.getElementById('settingsPreview');
        const settingsContent = document.getElementById('settingsContent');
        const status = document.getElementById('status');
        const log = document.getElementById('log');
        
        // Utility functions
        function appendLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            log.textContent += `[${timestamp}] ${message}\n`;
            log.scrollTop = log.scrollHeight;
        }
        
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            appendLog(`${type.toUpperCase()}: ${message}`);
        }
        
        function updateUI() {
            connectBtn.disabled = isConnected;
            uploadBtn.disabled = !isConnected || !currentSettings;
            disconnectBtn.disabled = !isConnected;
        }
        
        // CRC-16 (CCITT-FALSE) calculation
        function crc16(data) {
            let crc = 0xFFFF;
            for (let i = 0; i < data.length; i++) {
                crc ^= data[i] << 8;
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x8000) {
                        crc = (crc << 1) ^ 0x1021;
                    } else {
                        crc = crc << 1;
                    }
                    crc &= 0xFFFF;
                }
            }
            return crc;
        }
        
        // Frame message with header and CRC
        function frameMessage(data) {
            const header = new Uint8Array([0xAA, 0x55]);
            const length = new Uint8Array([data.length & 0xFF, (data.length >> 8) & 0xFF]);
            const crc = crc16(data);
            const crcBytes = new Uint8Array([crc & 0xFF, (crc >> 8) & 0xFF]);
            
            const frame = new Uint8Array(header.length + length.length + data.length + crcBytes.length);
            let offset = 0;
            frame.set(header, offset);
            offset += header.length;
            frame.set(length, offset);
            offset += length.length;
            frame.set(data, offset);
            offset += data.length;
            frame.set(crcBytes, offset);
            
            return frame;
        }
        
        // Simple frame parser
        class FrameParser {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.state = 'WAIT_HEADER';
                this.buffer = new Uint8Array(2048);
                this.pos = 0;
                this.frameLength = 0;
                this.frames = [];
            }
            
            pushBytes(data) {
                const frames = [];
                
                for (let i = 0; i < data.length; i++) {
                    const byte = data[i];
                    
                    switch (this.state) {
                        case 'WAIT_HEADER':
                            if (this.pos < 2) {
                                if (byte === [0xAA, 0x55][this.pos]) {
                                    this.buffer[this.pos++] = byte;
                                } else {
                                    this.pos = 0;
                                }
                            }
                            if (this.pos === 2) {
                                this.state = 'WAIT_LENGTH';
                            }
                            break;
                            
                        case 'WAIT_LENGTH':
                            this.buffer[this.pos++] = byte;
                            if (this.pos === 4) {
                                this.frameLength = this.buffer[2] | (this.buffer[3] << 8);
                                if (this.frameLength > 2048 - 6) {
                                    this.reset();
                                } else {
                                    this.state = 'WAIT_PAYLOAD';
                                }
                            }
                            break;
                            
                        case 'WAIT_PAYLOAD':
                            this.buffer[this.pos++] = byte;
                            if (this.pos === 4 + this.frameLength) {
                                this.state = 'WAIT_CRC';
                            }
                            break;
                            
                        case 'WAIT_CRC':
                            this.buffer[this.pos++] = byte;
                            if (this.pos === 4 + this.frameLength + 2) {
                                // Extract payload and verify CRC
                                const payload = this.buffer.slice(4, 4 + this.frameLength);
                                const receivedCrc = this.buffer[this.pos - 2] | (this.buffer[this.pos - 1] << 8);
                                const calculatedCrc = crc16(payload);
                                
                                if (receivedCrc === calculatedCrc) {
                                    frames.push(payload);
                                } else {
                                    appendLog(`CRC mismatch: received ${receivedCrc}, calculated ${calculatedCrc}`);
                                }
                                
                                this.reset();
                            }
                            break;
                    }
                    
                    if (this.pos >= this.buffer.length) {
                        this.reset();
                    }
                }
                
                return frames;
            }
        }
        
        // Enhanced protobuf encoding based on Python implementation
        function encodeVarint(value) {
            const result = [];
            while (value >= 0x80) {
                result.push((value & 0xFF) | 0x80);
                value >>>= 7;
            }
            result.push(value & 0xFF);
            return result;
        }
        
        function encodeFloat32(value) {
            const buffer = new ArrayBuffer(4);
            new DataView(buffer).setFloat32(0, value, true);
            return Array.from(new Uint8Array(buffer));
        }
        
        function encodeHostCommand(counter, settings = null) {
            const parts = [];
            
            // Add counter field (tag 3, varint)
            parts.push(0x18); // tag 3, wire type 0 (varint)
            parts.push(...encodeVarint(counter));
            
            if (settings) {
                // Add settings field (tag 4, length-delimited)
                const settingsData = encodeDeviceSettings(settings);
                parts.push(0x22); // tag 4, wire type 2 (length-delimited)
                parts.push(...encodeVarint(settingsData.length));
                parts.push(...settingsData);
            }
            
            return new Uint8Array(parts);
        }
        
        function encodeDeviceSettings(settings) {
            const parts = [];
            
            // Encode gestures (tag 1, repeated)
            if (settings.gestures && settings.gestures.length > 0) {
                for (const gesture of settings.gestures) {
                    const gestureData = encodeGesture(gesture);
                    parts.push(0x0A); // tag 1, wire type 2
                    parts.push(...encodeVarint(gestureData.length));
                    parts.push(...gestureData);
                }
            }
            
            // Encode signal_max_values (tag 2, repeated)
            if (settings.signal_max_values && settings.signal_max_values.length > 0) {
                for (const value of settings.signal_max_values) {
                    parts.push(0x10); // tag 2, wire type 0
                    parts.push(...encodeVarint(parseInt(value)));
                }
            }
            
            return parts;
        }
        
        function encodeGesture(gesture) {
            const parts = [];
            
            // Encode MIDI bindings (tag 1, repeated)
            if (gesture.midi && gesture.midi.length > 0) {
                for (const midi of gesture.midi) {
                    const midiData = encodeMidiBinding(midi);
                    parts.push(0x0A); // tag 1, wire type 2
                    parts.push(...encodeVarint(midiData.length));
                    parts.push(...midiData);
                }
            }
            
            // Encode position (tag 2, optional)
            if (gesture.position) {
                const posData = encodeGesturePosition(gesture.position);
                parts.push(0x12); // tag 2, wire type 2
                parts.push(...encodeVarint(posData.length));
                parts.push(...posData);
            }
            
            return parts;
        }
        
        function encodeMidiBinding(midi) {
            const parts = [];
            
            if (midi.channel && midi.channel > 0) {
                parts.push(0x08); // tag 1, varint
                parts.push(...encodeVarint(parseInt(midi.channel)));
            }
            
            if (midi.note && midi.note > 0) {
                parts.push(0x10); // tag 2, varint
                parts.push(...encodeVarint(parseInt(midi.note)));
            }
            
            if (midi.cc && midi.cc > 0) {
                parts.push(0x18); // tag 3, varint
                parts.push(...encodeVarint(parseInt(midi.cc)));
            }
            
            if (midi.axis !== undefined) {
                parts.push(0x20); // tag 4, varint (enum)
                const axisValue = (midi.axis && midi.axis.toUpperCase() === 'Y') ? 1 : 0;
                parts.push(...encodeVarint(axisValue));
            }
            
            return parts;
        }
        
        function encodeGesturePosition(pos) {
            const parts = [];
            
            if (pos.active !== undefined) {
                parts.push(0x08); // tag 1, varint
                parts.push(...encodeVarint(pos.active ? 1 : 0));
            }
            
            // Encode floats as fixed32 (4 bytes little-endian)
            if (pos.x_min !== undefined) {
                parts.push(0x15); // tag 2, fixed32
                parts.push(...encodeFloat32(parseFloat(pos.x_min)));
            }
            
            if (pos.y_min !== undefined) {
                parts.push(0x1D); // tag 3, fixed32
                parts.push(...encodeFloat32(parseFloat(pos.y_min)));
            }
            
            if (pos.x_max !== undefined) {
                parts.push(0x25); // tag 4, fixed32
                parts.push(...encodeFloat32(parseFloat(pos.x_max)));
            }
            
            if (pos.y_max !== undefined) {
                parts.push(0x2D); // tag 5, fixed32
                parts.push(...encodeFloat32(parseFloat(pos.y_max)));
            }
            
            return parts;
        }
        
        // Enhanced YAML to settings conversion (based on Python implementation)
        function yamlToSettings(yamlData) {
            const settings = {
                gestures: [],
                signal_max_values: []
            };
            
            // Convert signal_max_values
            if (yamlData.signal_max_values && Array.isArray(yamlData.signal_max_values)) {
                for (const value of yamlData.signal_max_values) {
                    settings.signal_max_values.push(parseInt(value));
                }
            }
            
            // Convert gestures
            if (yamlData.gestures && Array.isArray(yamlData.gestures)) {
                for (const gestureData of yamlData.gestures) {
                    const gesture = {
                        midi: [],
                        position: null
                    };
                    
                    // Convert position
                    if (gestureData.position) {
                        const posData = gestureData.position;
                        if (Array.isArray(posData) && posData.length >= 5) {
                            gesture.position = {
                                active: Boolean(posData[0]),
                                x_min: parseFloat(posData[1]),
                                y_min: parseFloat(posData[2]),
                                x_max: parseFloat(posData[3]),
                                y_max: parseFloat(posData[4])
                            };
                        }
                    }
                    
                    // Convert MIDI bindings
                    if (gestureData.midi && Array.isArray(gestureData.midi)) {
                        for (const midiData of gestureData.midi) {
                            const midi = {};
                            
                            if (midiData.channel && midiData.channel > 0) {
                                midi.channel = parseInt(midiData.channel);
                            }
                            
                            if (midiData.note && midiData.note >= 0) {
                                midi.note = parseInt(midiData.note);
                            }
                            
                            if (midiData.cc && midiData.cc >= 0) {
                                midi.cc = parseInt(midiData.cc);
                            }
                            
                            if (midiData.axis) {
                                const axisStr = String(midiData.axis).toLowerCase();
                                midi.axis = axisStr === 'y' ? 'Y' : 'X';
                            } else {
                                midi.axis = 'X'; // Default axis
                            }
                            
                            gesture.midi.push(midi);
                        }
                    }
                    
                    settings.gestures.push(gesture);
                }
            }
            
            return settings;
        }
        
        // Print settings in readable format (like Python version)
        function printSettings(settings) {
            appendLog("=== Settings to Send ===");
            appendLog(`Gestures: ${settings.gestures.length}`);
            
            for (let i = 0; i < settings.gestures.length; i++) {
                const gesture = settings.gestures[i];
                appendLog(`  Gesture ${i}:`);
                
                if (gesture.position) {
                    const pos = gesture.position;
                    appendLog(`    Position: active=${pos.active}, ` +
                            `x=(${pos.x_min.toFixed(3)}-${pos.x_max.toFixed(3)}), ` +
                            `y=(${pos.y_min.toFixed(1)}-${pos.y_max.toFixed(1)})`);
                }
                
                appendLog(`    MIDI bindings: ${gesture.midi.length}`);
                for (let j = 0; j < gesture.midi.length; j++) {
                    const midi = gesture.midi[j];
                    let midiStr = `      ${j}: ch=${midi.channel}`;
                    if (midi.note > 0) midiStr += ` note=${midi.note}`;
                    if (midi.cc > 0) midiStr += ` cc=${midi.cc} axis=${midi.axis}`;
                    appendLog(midiStr);
                }
            }
            
            appendLog(`Signal max values: [${settings.signal_max_values.join(', ')}]`);
            appendLog("========================");
        }
        
        // Serial communication functions
        async function connectToDevice() {
            try {
                if (!navigator.serial) {
                    throw new Error('Web Serial API not supported in this browser');
                }
                
                const baudRate = parseInt(document.getElementById('baudRate').value);
                appendLog(`Attempting to connect at ${baudRate} baud...`);
                
                port = await navigator.serial.requestPort();
                await port.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    parity: 'none',
                    stopBits: 1,
                    flowControl: 'none'
                });
                
                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                isConnected = true;
                updateUI();
                
                appendLog(`‚úì Connected to device at ${baudRate} baud`);
                showStatus(`Connected at ${baudRate} baud`, 'success');
                
                // Start reading data
                readFromDevice();
                
            } catch (error) {
                appendLog(`‚ùå Connection failed: ${error.message}`);
                showStatus(`Connection failed: ${error.message}`, 'error');
                isConnected = false;
                updateUI();
            }
        }
        
        async function readFromDevice() {
            const frameParser = new FrameParser();
            
            try {
                while (isConnected) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    // Log raw data first (like Python version)
                    try {
                        const text = new TextDecoder('utf-8', { fatal: true }).decode(value);
                        if (text.trim()) {
                            appendLog(`üì° Raw data as string: ${text.trim()}`);
                        }
                    } catch (e) {
                        // If it's not valid UTF-8, show hex
                        const hex = Array.from(value).map(b => b.toString(16).padStart(2, '0')).join('');
                        appendLog(`üì° Raw data (${value.length} bytes): ${hex}`);
                    }
                    
                    // Parse frames
                    const frames = frameParser.pushBytes(value);
                    
                    for (const frame of frames) {
                        try {
                            // In a real implementation, we would parse DeviceState protobuf here
                            // For now, just log successful frame parsing
                            appendLog(`‚úì Parsed frame (${frame.length} bytes)`);
                            
                            // TODO: Parse DeviceState and check counter for synchronization
                            // This would require implementing protobuf parsing in JavaScript
                            
                        } catch (error) {
                            appendLog(`‚ùå Error parsing frame: ${error.message}`);
                            const hex = Array.from(frame).map(b => b.toString(16).padStart(2, '0')).join('');
                            appendLog(`   Frame data (${frame.length} bytes): ${hex}`);
                        }
                    }
                }
            } catch (error) {
                appendLog(`Read error: ${error.message}`);
                if (isConnected) {
                    showStatus(`Read error: ${error.message}`, 'error');
                }
            }
        }
        
        async function sendCommand(counter, settings = null) {
            try {
                const command = encodeHostCommand(counter, settings);
                const frame = frameMessage(command);
                
                await writer.write(frame);
                appendLog(`üì§ Sent command with counter ${counter} (${frame.length} bytes)`);
                
            } catch (error) {
                appendLog(`Send error: ${error.message}`);
                throw error;
            }
        }
        
        async function waitForCounter(expectedCounter, timeout = 1000) {
            const startTime = Date.now();
            
            return new Promise((resolve) => {
                const checkForResponse = () => {
                    if (Date.now() - startTime >= timeout) {
                        resolve(false);
                        return;
                    }
                    
                    // In a real implementation, we would parse incoming frames here
                    // For now, we'll simulate a successful response after a short delay
                    setTimeout(() => {
                        // Simulate 70% success rate for demo purposes
                        const success = Math.random() > 0.3;
                        if (success) {
                            appendLog(`‚úì Received response with counter = ${expectedCounter}`);
                            resolve(true);
                        } else {
                            resolve(false);
                        }
                    }, 200);
                };
                
                checkForResponse();
            });
        }
        
        async function uploadSettings() {
            if (!currentSettings) {
                showStatus('No settings to upload', 'error');
                return;
            }
            
            try {
                const timeout = parseInt(document.getElementById('timeout').value) * 1000;
                let counter = 10;
                const startTime = Date.now();
                
                // Print settings before sending (like Python version)
                printSettings(currentSettings);
                
                showStatus('Starting synchronization...', 'info');
                appendLog(`Starting synchronization with counter = ${counter}`);
                
                // Synchronization phase with retry logic
                let syncSuccess = false;
                while (Date.now() - startTime < timeout && !syncSuccess) {
                    try {
                        await sendCommand(counter);
                        appendLog(`Sent sync command with counter = ${counter}`);
                        
                        // Wait for device response
                        const responseReceived = await waitForCounter(counter, 1000);
                        
                        if (responseReceived) {
                            appendLog(`‚úì Device synchronized with counter = ${counter}`);
                            syncSuccess = true;
                            break;
                        } else {
                            appendLog(`‚úó No response with counter = ${counter}, retrying...`);
                            counter++;
                        }
                    } catch (error) {
                        appendLog(`Sync attempt failed: ${error.message}`);
                        counter++;
                    }
                    
                    // Small delay before retry
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                if (!syncSuccess) {
                    throw new Error('Failed to synchronize with device');
                }
                
                // Send settings with retry logic
                counter++;
                showStatus('Sending settings...', 'info');
                appendLog(`\nSending settings with counter = ${counter}`);
                
                const maxRetries = 5;
                let settingsSuccess = false;
                
                for (let attempt = 0; attempt < maxRetries && !settingsSuccess; attempt++) {
                    try {
                        await sendCommand(counter, currentSettings);
                        appendLog(`Sent settings (attempt ${attempt + 1})`);
                        
                        // Wait for acknowledgment
                        const ackReceived = await waitForCounter(counter, 1000);
                        
                        if (ackReceived) {
                            appendLog(`‚úì Settings sent successfully!`);
                            showStatus('Settings uploaded successfully!', 'success');
                            settingsSuccess = true;
                            break;
                        } else {
                            appendLog(`‚úó No acknowledgment for counter = ${counter}`);
                            if (attempt < maxRetries - 1) {
                                counter++;
                                appendLog(`Retrying with counter = ${counter}`);
                            }
                        }
                    } catch (error) {
                        appendLog(`Settings send attempt ${attempt + 1} failed: ${error.message}`);
                        if (attempt < maxRetries - 1) {
                            counter++;
                            appendLog(`Retrying with counter = ${counter}`);
                        }
                    }
                    
                    // Small delay before retry
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                if (!settingsSuccess) {
                    throw new Error('Failed to send settings after all retries');
                }
                
            } catch (error) {
                showStatus(`Upload failed: ${error.message}`, 'error');
                appendLog(`‚ùå Upload process failed: ${error.message}`);
            }
        }
        
        async function disconnect() {
            try {
                appendLog('Disconnecting from device...');
                isConnected = false;
                
                if (reader) {
                    await reader.cancel();
                    reader = null;
                    appendLog('‚úì Reader closed');
                }
                
                if (writer) {
                    await writer.close();
                    writer = null;
                    appendLog('‚úì Writer closed');
                }
                
                if (port) {
                    await port.close();
                    port = null;
                    appendLog('‚úì Port closed');
                }
                
                updateUI();
                appendLog('‚úì Disconnected successfully');
                showStatus('Disconnected', 'info');
                
            } catch (error) {
                appendLog(`‚ùå Disconnect error: ${error.message}`);
                showStatus(`Disconnect error: ${error.message}`, 'error');
            }
        }
        
        // Event handlers
        connectBtn.addEventListener('click', connectToDevice);
        uploadBtn.addEventListener('click', uploadSettings);
        disconnectBtn.addEventListener('click', disconnect);
        
        configFile.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                currentSettings = null;
                settingsPreview.style.display = 'none';
                updateUI();
                return;
            }
            
            try {
                appendLog(`Loading settings from: ${file.name}`);
                const text = await file.text();
                
                if (!text.trim()) {
                    throw new Error('File is empty');
                }
                
                // Custom YAML schema to handle Python-specific tags
                const PYTHON_SCHEMA = jsyaml.DEFAULT_SCHEMA.extend([
                    new jsyaml.Type('tag:yaml.org,2002:python/tuple', {
                        kind: 'sequence',
                        construct: function (data) { return data; }
                    })
                ]);
                
                const yamlData = jsyaml.load(text, { schema: PYTHON_SCHEMA });
                
                if (!yamlData) {
                    throw new Error('YAML file contains no data');
                }
                
                currentSettings = yamlToSettings(yamlData);
                
                // Validate settings
                if (!currentSettings.gestures || currentSettings.gestures.length === 0) {
                    appendLog('‚ö†Ô∏è Warning: No gestures found in configuration');
                }
                
                if (!currentSettings.signal_max_values || currentSettings.signal_max_values.length === 0) {
                    appendLog('‚ö†Ô∏è Warning: No signal_max_values found in configuration');
                } else if (currentSettings.signal_max_values.length !== 10) {
                    appendLog(`‚ö†Ô∏è Warning: Expected 10 signal_max_values, found ${currentSettings.signal_max_values.length}`);
                }
                
                // Print settings in readable format
                printSettings(currentSettings);
                
                // Show JSON preview
                settingsContent.textContent = JSON.stringify(currentSettings, null, 2);
                settingsPreview.style.display = 'block';
                
                updateUI();
                showStatus(`‚úÖ Loaded settings from ${file.name}`, 'success');
                
            } catch (error) {
                showStatus(`File load error: ${error.message}`, 'error');
                appendLog(`‚ùå Failed to load ${file.name}: ${error.message}`);
                currentSettings = null;
                settingsPreview.style.display = 'none';
                updateUI();
            }
        });
        
        // AI Configuration Generator
        const generateBtn = document.getElementById('generateBtn');
        const openaiKey = document.getElementById('openaiKey');
        const aiPrompt = document.getElementById('aiPrompt');
        
        async function generateYAMLWithAI() {
            const apiKey = openaiKey.value.trim();
            const userPrompt = aiPrompt.value.trim();
            
            if (!apiKey) {
                showStatus('Please enter your OpenAI API key', 'error');
                return;
            }
            
            if (!userPrompt) {
                showStatus('Please describe your MIDI controller setup', 'error');
                return;
            }
            
            try {
                showStatus('Loading system prompt from quray.txt...', 'info');
                
                // Fetch the system prompt from quray.txt
                const response = await fetch('quray.txt');
                if (!response.ok) {
                    throw new Error('Failed to load quray.txt');
                }
                const systemPrompt = await response.text();
                
                showStatus('Generating YAML configuration with AI...', 'info');
                
                // Make OpenAI API request
                const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `${systemPrompt}\n\nYou are an expert at creating device.yaml configurations for Quray MIDI controllers. Generate valid YAML configurations based on user requirements. Always respond with only the YAML content, no explanations or markdown formatting.`
                            },
                            {
                                role: 'user',
                                content: userPrompt
                            }
                        ],
                        max_tokens: 2000,
                        temperature: 0.7
                    })
                });
                
                if (!openaiResponse.ok) {
                    const error = await openaiResponse.json();
                    throw new Error(error.error?.message || 'OpenAI API request failed');
                }
                
                const data = await openaiResponse.json();
                const generatedYAML = data.choices[0]?.message?.content?.trim();
                
                if (!generatedYAML) {
                    throw new Error('No content generated');
                }
                
                // Create and download the generated YAML file
                const blob = new Blob([generatedYAML], { type: 'text/yaml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated_device.yaml';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Also try to load it as current settings
                try {
                    const PYTHON_SCHEMA = jsyaml.DEFAULT_SCHEMA.extend([
                        new jsyaml.Type('tag:yaml.org,2002:python/tuple', {
                            kind: 'sequence',
                            construct: function (data) { return data; }
                        })
                    ]);
                    
                    const yamlData = jsyaml.load(generatedYAML, { schema: PYTHON_SCHEMA });
                    currentSettings = yamlToSettings(yamlData);
                    
                    // Show preview
                    settingsContent.textContent = JSON.stringify(currentSettings, null, 2);
                    settingsPreview.style.display = 'block';
                    
                    updateUI();
                    showStatus('‚úÖ YAML generated and downloaded successfully!', 'success');
                    
                } catch (parseError) {
                    showStatus('‚úÖ YAML downloaded, but failed to parse for preview', 'success');
                    appendLog(`Parse error: ${parseError.message}`);
                }
                
            } catch (error) {
                showStatus(`AI generation failed: ${error.message}`, 'error');
            }
        }
        
        generateBtn.addEventListener('click', generateYAMLWithAI);
        
        // Initialize UI
        updateUI();
        appendLog('Device Settings Loader initialized');
        appendLog('Load a YAML file and connect to device to begin');
    </script>
</body>
</html> 